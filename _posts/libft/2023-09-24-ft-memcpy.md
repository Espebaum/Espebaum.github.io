---
layout: post
title: "ft_memcpy"
description: >
    "ft_memcpy에 대하여"
category: libft
---
## ft_memcmp

### <목차>
{:.lead}
[1. MY CODES](#1-my-codes)

[2. MAN MEMCPY](#2-man-memcpy)

> memcpy --- copy memory area

## (1) MY CODES

~~~c
#include "libft.h"

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	unsigned char	*new_dest;
	unsigned char	*new_src;
	size_t			i;

	if (dest == src)
		return (dest);	// block self-copy
	new_dest = (unsigned char *) dest;
	new_src = (unsigned char *) src;
	i = 0;
	while (i++ < n)
		*new_dest++ = *new_src++;
	return (dest);
}
~~~
- 메모리 영역 src로부터 n bytes 만큼을 메모리 영역 dest로 복사한다. 메모리 영역은 overlap 되어서는 안 된다.

## (2) MAN MEMCPY
~~~plain
SYNOPSIS
	#include <string.h>

       void *memcpy(void *dest, const void *src, size_t n);

DESCRIPTION
	The memcpy() function copies n bytes from memory area src to memory area dest.
	The memory areas must not overlap. Use memmove(3) if the memory areas do overlap.

RETURN VALUE
	The memcpy() function returns a pointer to dest.

NOTE
	Failure to observe the requirement that the memory areas do not overlap
	has been the source of significant bugs. (POSIX and the C standards are 
	explicit that employing memcpy() with overlapping areas produces undefined 
	behavior.) Most notably, in glibc 2.13 a performance optimization of memcpy()
	on some platforms (including x86-64) included changing the order in which bytes 
	were copied from src to dest. ... (중략)
~~~

- 매개 변수로 들어온 void* dest와 void* src에 대해 n 바이트만큼을 복사하는 함수이다.
- NOTE에 따르면 메모리가 overlap되어야 한다는 규칙을 준수하지 않는 것은 심각한 버그를 발생시켰다고 한다. 또 POSIX와 C 표준은 memcpy()를 겹치는 영역에서 사용하는 것이 정의되지 않은 동작을 생성한다고 명시한다고 한다. 잘 알려진 예시를 살펴보자.

~~~c
#include <stdio.h>
#include <string.h>
 
int main() 
{
    int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    memcpy(a + 1, a, 9 * sizeof(int));

    for (int i = 0; i < 10; i++) 
	{
        printf("%d ", a[i]);
    }
    return 0;
}
~~~
~~~plain
output:
1 1 2 3 4 5 6 7 8 9 혹은 1 1 1 1 1 1 1 1 1
~~~

- 코드의 의도는