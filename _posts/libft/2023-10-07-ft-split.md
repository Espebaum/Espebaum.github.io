---
layout: post
title: "ft_split"
description: >
    "ft_split에 대하여"
category: libft
---
## ft_split

### <목차>
{:.lead}
[1. MY CODES](#1-my-codes)

[2. 사용과 설명](#2-사용과-설명)

> ft_split -- 매개변수로 문자열과 구분자를 받아서, 구분자를 기준으로 문자열을 쪼개 이중 배열을 만들고 반환한다.

## (1) MY CODES
~~~c
#include "libft.h"

static int	is_sep(char s, char c)
{
	if (s == c || s == 0)
		return (1);
	return (0);
}

static int	count_size(char const *s, char c)
{
	int	s_size;

	s_size = 0;
	while (*s)
	{
		if (!is_sep(*s, c) && is_sep(*(s + 1), c))
			s_size++;
		s++;
	}
	return (s_size);
}

static void	ft_freeall(char **spl)
{
	size_t	j;

	j = 0;
	while (spl[j])
	{
		free(spl[j]);
		j++;
	}
	free(spl);
	return ;
}

static void	place_word(char **spl, char const *s, char c, int *flag)
{
	int		s_idx;
	int		i;

	s_idx = 0;
	while (*s)
	{
		if (is_sep(*s, c))
			s++;
		else
		{
			i = 0;
			while (*(s + i) && !is_sep(*(s + i), c))
				i++;
			spl[s_idx] = ft_substr(s, 0, i);
			if (spl[s_idx] == NULL)
			{
				*flag = 1;
				ft_freeall(spl);
				return ;
			}
			s_idx += 1;
			s += i;
		}
	}
}

char	**ft_split(char const *s, char c)
{
	char	**spl;
	int		s_size;
	int		flag;

	flag = 0;
	if (!s)
		return (NULL);
	s_size = count_size(s, c);
	spl = (char **) malloc(sizeof(char *) * (s_size + 1));
	if (spl == NULL)
		return (NULL);
	place_word(spl, s, c, &flag);
	if (flag == 1)
		return (NULL);
	spl[s_size] = NULL;
	return (spl);
}
~~~
- libft에서 만들었던 문자열 처리 함수 중 가장 높은 난이도를 자랑하는 `ft_split()` 되시겠다.

## (2) 사용과 설명
~~~c
int main()
{
	char	*s = "abc1def1ghi";
	char	**spl = ft_split(s, '1');
	for (int i = 0; spl[i] != NULL; i++)
		printf("%s ", spl[i]);
	printf("\n");
	return 0;
}
~~~
~~~plain
output :
	abc def ghi
~~~
- 문자열 "abc1def1ghi"과 구분자 '1'을 받아서 이중 배열 "`abc` `def` `ghi`" 을 반환받았다. 보통 공백을 기준으로 문자열을 쪼개지만, 공백이 아니라 다른 구분자로 쪼갤 수도 있다.

- 함수는 다음과 같이 진행된다.

### (1) 이중 배열의 길이를 구한다.
~~~c
static int	is_sep(char s, char c)
{
	if (s == c || s == 0) // 구분자와 NUL일 때
		return (1);
	return (0);
}

static int	count_size(char const *s, char c)
{
	int	s_size;

	s_size = 0;
	while (*s)
	{
		if (!is_sep(*s, c) && is_sep(*(s + 1), c))
			s_size++; 
			// 해당 문자가 구분자가 아닌데 다음 문자가 구분자라면 이중 배열의 길이를 하나 늘려줌
		s++;
	}
	return (s_size);
}
~~~
- 문자열을 순회하면서 **인덱스와 그 다음 인덱스를 동시에 확인**해서, 해당 문자가 구분자가 아닌데 다음 문자가 구분자라면 이중 배열의 길이를 하나 늘려준다. "abc1defghi"의 경우
~~~plain
      ↓       ↓       ↓    
a b c 1 d e f 1 g h i \0
~~~
- 이 지점에서 이중 배열의 길이가 늘어나게 된다. 

## (2) 할당된 이중 배열을 원본 문자열로 채워준다
~~~c
static void	place_word(char **spl, char const *s, char c, int *flag)
{
	int		s_idx;
	int		i;

	s_idx = 0;
	while (*s)
	{
		if (is_sep(*s, c))
			s++;
		else
		{
			i = 0;
			while (*(s + i) && !is_sep(*(s + i), c))
				i++;
			spl[s_idx] = ft_substr(s, 0, i);
			if (spl[s_idx] == NULL)
			{
				*flag = 1;
				ft_freeall(spl);
				return ;
			}
			s_idx += 1;
			s += i;
		}
	}
}
~~~