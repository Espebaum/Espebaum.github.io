---
layout: post
title: "ft_atoi"
description: >
    "atoi에 대하여"
category: libft
---
## ft_atoi

> **convert ASCII string to integer**

### (1) MY CODE

~~~c
#include "libft.h"

static int	is_space(char c)
{
	if (c == 9 || c == 10 || c == 11
		|| c == 12 || c == 13 || c == 32)
		return (1);
	else
		return (0);
}

int	ft_atoi(const char *str)
{
	long long	cnt;
	long long	is_minus;

	cnt = 0;
	is_minus = 1;
	while (*str)
	{
		if (is_space(*str))
			str++;
		else
			break ;
	}
	if (*str == '-' || *str == '+')
	{
		if (*str == '-')
			is_minus *= -1;
		str++;
	}
	while (ft_isdigit(*str))
	{
		cnt *= 10;
		cnt += *str - '0';
		str++;
	}
	return (is_minus * cnt);
}
~~~

Libft를 진행하던 당시 작성했었던 코드. Norminette과 내 유치한 실력이 버무려져 탄생한 볼품없는 코드.

## (2) MAN ATOI

- 라피신을 진행하면서 뿐만 아니라, Libft를 만들면서도 듣는 충고가 man을 열심히 보라는 것이다. 그때 당시에는 귀담아듣지 않았는데 지금 생각해보면 Libft를 만들 때만큼은 좀 봐두는 게 좋지 않았나 싶다.

~~~plain
SYNOPSIS
 #include <stdlib.h>

 int     atoi(const char *str);

DESCRIPTION
 - The atoi() function converts the initial portion of the string pointed to by str
 to int representation.

	-> It is equivalent to:

		(int) strtol(str, (char **)NULL, 10);
~~~

- 딱 봐도 "**It is equivalent to ~**" 부분이 제일 중요하다. 맞다, `atoi()`는 libc에 의해 내부적으로 `strtol()`을 돌려 결과를 반환하는 방식을 사용한다. 그렇다면 `strtol()`의 MAN을 보지 않을 수가 없다.

## (3) MAN STRTOL
~~~plain
NAME
 strtol -- convert a string value to a long (strtoimax, strtoll, strtoq의 대한 설명은 제외)

SYNOPSIS
 #include <stdlib.h>

  long     strtol(const char *restrict str, char **restrict endptr, int base);

DESCRIPTION
 - The strtol() function converts the string in str to a long value. (중략) The string may 
 begin with an arbitrary amount of whitespace (as determined by isspace(3)) followed by a 
 single optional "+" or "-" sign. If base is zero or 16, the string may then include a 
 "0x" prefix, and the number will be read in base 16; otherwise, a zero base is taken 
 as 10 (decimal) unless the next character is "0", in which case it is taken as 8 (octal).
 
 - The remainder of the string is converted to a long in the obvious manner, stopping 
 at the first character which is not a valid digit in the given base. (In bases above 10, 
 the letter `A' in either upper or lower case represents 10, `B' represents 11, 
 and so forth, with `Z' representing 35.)

 - If endptr is not NULL, strtol() stores the address of the first invalid character 
 in *endptr. If there were no digits at all, however, strtol() stores the original
 value of str in *endptr. (Thus, if *str is not "\0" but **endptr is "\0" on return, 
 the entire string was valid.)

RETURN VALUE
 - The strtol() functions return the result of the conversion, unless the value would 
 underflow or overflow.  If no conversion could be performed, 0 is returned and the 
 global variable errno is set to EINVAL (the last feature is not portable across 
 all platforms).  If an overflow or underflow occurs, errno is set to ERANGE and 
 the function return value is clamped according to the following table.

           Function       underflow     overflow
           strtol()       LONG_MIN      LONG_MAX
~~~

- 봐야 할 포인트가 한두가지가 아니어서 사실상 man 전체를 긁어왔다(그래도 나름 선별해서 가져왔다).
- const char* str가 변환할 문자열, 그리고 char** endptr은 변환 작업 후 위치할 포인터의 포인터, 그리고 base는 진법을 의미한다.
- 먼저 str의 앞부터 존재할 수 있는 임의의 공백들을 조사한다. 공백 문자들은 man isspace(3)에 정의된 것들을 의미한다. 살펴보자면

~~~plain
MAN ISSPACE(3)

SYNOPSIS
 #include <ctype.h>

DESCRIPTION
 The isspace() function tests for the white-space characters.  For any
     locale, this includes the following standard characters:

   -> "\t"   "\n"    "\v"    "\f"    "\r"    " "
~~~

- 이 여섯 가지 문자들을 의미한다.
  - "\t"는 수평 탭(Horizontal Tab, 9, HT)으로 우리에게 잘 알려져 있는 바로 그 Tab이다. 
  - "\n"은 개행(Line Feed, 10, LF)이다. 줄을 내린 후 커서를 맨 왼쪽으로 끌어 당긴다. 타자기 시절에는 줄을 내리는 것만이 LF이고 왼쪽으로 당기는 것은 CR이어서 온전히 한 줄을 내리기 위해서는 CRLF을 했어야 했지만, 현대에 와서는 LF만으로 줄을 내릴 수 있게 되었다.
  - "\v"는 수직 탭(Vertical Tab, 11, VT)으로 바로 밑으로 커서를 내린다.
  - "\f"는 폼 피드(Form Feed, 12, FF)로, 프린터가 용지의 한 페이지 길이에 해당하는 만큼 페이지를 넘기거나 다음 페이지의 제일 첫 부분으로 넘기게 하는 특수 문자이다.
  - "\r"는 캐리지 리턴(Carrige Return, 13, CR)로 커서를 맨 왼쪽으로 끌어당긴다.
  - " "는 공백(Space, 32, SP(C))이다.

- 사용 결과는 대략 다음과 같다.
~~~C
#include <stdio.h>

int main()
{
	printf("abc\ndef");
	printf("\n");
	printf("abc\fdef");
	printf("\n");
	printf("abc\vdef");
	printf("\n");
	printf("abc\rdef");
	printf("\n");
}
~~~
~~~plain
output:
         abc
         def
         abc
            def
         abc
            def
         def (커서가 당겨져서 abc가 없어져버림)
~~~ 

- 임의의 수로 들어온 공백들을 체크하고 난 이후에는 본격적으로 숫자를 보게 된다. atoi는 10진수만 체크하므로 "0x"나 "0"같은 접두사를 볼 필요는 없다.