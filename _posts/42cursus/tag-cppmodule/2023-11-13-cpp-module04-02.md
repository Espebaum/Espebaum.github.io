---
layout: post
title: "cpp_module_04"
description: >
    "CPP Module 04에 대하여"
category: 42cursus
tags: cppmodule
---

## CPP Module 04 (2)

* table of contents
{:toc}

> Subtype polymorphism, abstract classes, interfaces

> 런타임 다형성의 모든 것

## ex03: Interface & recap

> 4서클 CPP MODULE의 최대 난제

### C++ Interface

- 소멸자(virtual)와 순수 가상 함수만이 선언된 클래스, 반드시 파생 클래스를 구현하여 override 해야만 한다. subject에 `ICharacter`와 `IMateria` 클래스가 인터페이스의 예시로 제시되어 있다. 아무것도 구현할 필요가 없으니 cpp 파일 또한 필요없다. 따라서 `ICharacter`와 `IMateria`는 .hpp 파일로만 존재한다.

~~~c++
class ICharacter
{
    public:
        virtual ~ICharacter() {}
        virtual std::string const & getName() const = 0;
        virtual void equip(AMateria* m) = 0;
        virtual void unequip(int idx) = 0;
        virtual void use(int idx, ICharacter& target) = 0;
};

class IMateriaSource
{
    public:
        virtual ~IMateriaSource() {}
        virtual void learnMateria(AMateria*) = 0;
        virtual AMateria* createMateria(std::string const & type) = 0;
};
~~~

### Interface와 결합

- Interface는 객체들의 강한 결합(Tight Coupling)을 약한 결합(Loose Coupling)으로 바꾸어놓는 것에 그 용도가 있다. 객체가 강하게 결합되어 있다는 것이 무슨 의미일까?

#### 강한 결합(Tight Coupling)

- 코드를 구현하며 강한 결합의 형태를 살펴보자. 예시로 `Character` 클래스와, `Cure` 클래스를 구현해보았다.

**<span style="color:green">Cure</span>**
~~~c++
class Cure
{
    protected:
        std::string type; // "Cure"
    public:
        Cure();
        Cure(const Cure& ref);
        ~Cure();
        Cure& operator=(const Cure& ref);
};
~~~

**<span style="color:purple">Character</span>**
~~~c++
class Character
{
    private:
        std::string name;    
        Cure*    c;
    public:
        Character(std::string name_);
        Character(const Character &ref);
        Character &operator=(const Character &ref);
        ~Character();

        std::string const& getName() const;
        void equip(Cure* c);
        void unequip();
        void use(std::string target);
};
~~~

**<span>main.cpp</span>**
~~~c++
#include "Cure.hpp"
#include "Character.hpp"

int main()
{
    Character*   c1 = new Character("Bob");
    Cure*   s1 = new Cure();

    c1->equip(s1);
    c1->use("Dummy");
    c1->unequip();

    delete c1;
    delete s1;

	return 0;
}
~~~

- 그닥 어렵지 않게 생각해낼 수 있었다. main.cpp의 주요 부분인 `Cure` 클래스의 equip, use, unequip을 확인해보자.

~~~c++
void    Character::equip(Cure*  cure)
{
    if (this->c)
        return ;
    this->c = cure;
}

void    Character::unequip()
{
    if (!this->c)
        return ;
    //delete this->c; Cure를 해제하지 않고, 포인터만 NULL로 변경
    this->c = NULL;    
}

void    Character::use(std::string target)
{
    if (!this->c)
        std::cout << "Cannot use Spell" << std::endl;
    std::cout << "** " << "heals " << target << "\'s wound **" << std::endl;
}
~~~

- `void Character::equip(Cure* cure)`은 Cure 포인터를 받아서 Chracter의 Cure 포인터 자리에 장비시키며, `void Character::unequip()`은 Character의 Cure 포인터를 NULL로 바꾸어준다. 원래 장비하고 있던 Cure 포인터는 main에서 해제해준다든지 해서 적절히 관리되어야 할 것이다. `void Character::use(std::string target)`은 매개 변수로 들어온 target에게 Cure 스펠을 사용한다. 여기까지는 문제가 없다. **그러나 여기에 새로운 Spell인 Ice가 추가된다면 어떨까?**

**<span style="color:Aqua">Ice</span>**
~~~c++
class Ice
{
    protected:
        std::string type; // "Ice"
    public:
        Ice();
        Ice(const Ice& ref);
        ~Ice();
        Ice& operator=(const Ice& ref);
};
~~~

- Ice를 추가하는 것 자체는 어려운 일이 아니다. 그런데 `Character`가 Ice를 새롭게 배우기 위해서는 코드에 변화가 있어야 한다. 기존의 `equip, unequip, use`는 Cure 스펠만을 상정한 채 설계되었기 때문이다. 이런 식으로 바꿀 수 있을지도 모르겠다.

~~~c++
class Character
{
    private:
        std::string name;
        Cure*    c;
        Ice*     i;
    public:
        // ... implementation
        void equipCure(Cure* c);
        void unequipCure();
        void useCure(std::string target);

        void equipIce(Ice *i);
        void unequipIce();
        void useIce(std::string target);
};
~~~

- `Character`는 `Cure` 이외에 `Ice`를 위한 새로운 멤버 변수를 가져야 할 것이다. 또한 Cure 만을 상정한 `equipCure, unequipCure, useCure` 이외에, Ice를 받을 수 있는 새로운 함수 ice 시리즈(`equipIce, unequipIce, useIce`)를 만들어야 할 것이다. 

- 코드 줄이 늘어나는 것이 별로 유쾌한 광경은 아니다. 뿐만 아니라 이런 식으로 코드가 변경되면, 이 프로그램은 **개방 폐쇄의 원칙(Open Close Principle)을 위배하게 된다.**

- **개방 폐쇄의 원칙(OCP)이란 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계가 되어야 한다는 원칙을 말한다.** 보통 OCP를 확장에 대해서는 개방적(open)이고, 수정에 대해서는 폐쇄적(closed)이어야 한다는 의미로 정의한다. 이 말은 Ice를 추가했을 때, 기존의 Character 클래스가 수정되어서는 안된다는 것이다.


### concrete class

- 정의한 모든 연산(operation)이나 일부 연산의 구현을 서브 클래스로 넘기는 추상 클래스(abstract class)나 객체의 연산에 대한 구현이 포함되어 있지 않고 정의만 존재하는 인터페이스를 통해 인스턴스를 만들 수 없다. 완성되지 않은 설계도를 가지고 제품을 만들 수는 없기 때문이다.

- **모든 연산에 대한 구현을 가지고 있는 클래스가 바로 concrete class이다. 추상 클래스가 아닌 클래스는 모두 concrete class라고 할 수 있다**. 정의한 모든 연산에 대한 구현을 가지고 있는 완전한 클래스이므로 우리는 이 클래스의 인스턴스를 만들 수 있다.


