---
layout: post
title: "cpp_module_04"
description: >
    "CPP Module 04에 대하여"
category: 42cursus
tags: cppmodule
---

## CPP Module 04 (2)

* table of contents
{:toc}

> Subtype polymorphism, abstract classes, interfaces

> 런타임 다형성의 모든 것

## ex03: Interface & recap

> 4서클 CPP MODULE의 최대 난제

### C++ Interface

- 소멸자(virtual)와 순수 가상 함수만이 선언된 클래스, 반드시 파생 클래스를 구현하여 override 해야만 한다. subject에 `ICharacter`와 `IMateria` 클래스가 인터페이스의 예시로 제시되어 있다. 아무것도 구현할 필요가 없으니 cpp 파일 또한 필요없다. 따라서 `ICharacter`와 `IMateria`는 .hpp 파일로만 존재한다.

~~~c++
class ICharacter
{
    public:
        virtual ~ICharacter() {}
        virtual std::string const & getName() const = 0;
        virtual void equip(AMateria* m) = 0;
        virtual void unequip(int idx) = 0;
        virtual void use(int idx, ICharacter& target) = 0;
};

class IMateriaSource
{
    public:
        virtual ~IMateriaSource() {}
        virtual void learnMateria(AMateria*) = 0;
        virtual AMateria* createMateria(std::string const & type) = 0;
};
~~~

### Interface와 결합

- Interface는 객체들의 강한 결합(Tight Coupling)을 약한 결합(Loose Coupling)으로 바꾸어놓는 것에 그 용도가 있다. 객체가 강하게 결합되어 있다는 것이 무슨 의미일까?

#### 강한 결합(Tight Coupling)

- 대략적인 코드를 구현하며 강한 결합의 형태를 살펴보자. 예시로 `Character` 클래스와, `Cure` 클래스를 구현해보았다.

**<span style="color:green">Cure</span>**
~~~c++
class Cure
{
    protected:
        std::string type; // "Cure"
    public:
        Cure();
        Cure(const Cure& ref);
        ~Cure();
        Cure& operator=(const Cure& ref);
};
~~~

**<span style="color:purple">Character</span>**
~~~c++
class Character
{
    private:
        std::string name;    
        Cure*    c;
    public:
        Character(std::string name_);
        Character(const Character &ref);
        Character &operator=(const Character &ref);
        ~Character();

        std::string const& getName() const;
        void equip(Cure* c);
        void unequip();
        void use(std::string target);
};
~~~

**<span>main.cpp</span>**
~~~c++
#include "Cure.hpp"
#include "Character.hpp"

int main()
{
    Character*   c1 = new Character("Bob");
    Cure*   s1 = new Cure();

    c1->equip(s1);
    c1->use("Dummy");
    c1->unequip();

    delete c1;
    delete s1;

    return 0;
}
~~~

- 그닥 어렵지 않게 생각해낼 수 있었다. main.cpp의 주요 부분인 `Cure` 클래스의 equip, use, unequip을 확인해보자.

~~~c++
void    Character::equip(Cure*  cure)
{
    if (this->c)
        return ;
    this->c = cure;
}

void    Character::unequip()
{
    if (!this->c)
        return ;
    //delete this->c; Cure를 해제하지 않고, 포인터만 NULL로 변경
    this->c = NULL;    
}

void    Character::use(std::string target)
{
    if (!this->c)
        std::cout << "Cannot use Spell" << std::endl;
    std::cout << "** " << "heals " << target << "\'s wound **" << std::endl;
}
~~~

- `void Character::equip(Cure* cure)`은 Cure 포인터를 받아서 Chracter의 Cure 포인터 자리에 장비시키며, `void Character::unequip()`은 Character의 Cure 포인터를 NULL로 바꾸어준다. 원래 장비하고 있던 Cure 포인터는 main에서 해제해준다든지 해서 적절히 관리되어야 할 것이다. `void Character::use(std::string target)`은 매개 변수로 들어온 target에게 Cure 스펠을 사용한다. 여기까지는 문제가 없다. **그러나 여기에 새로운 Spell인 Ice가 추가된다면 어떨까?**

**<span style="color:Aqua">Ice</span>**
~~~c++
class Ice
{
    protected:
        std::string type; // "Ice"
    public:
        Ice();
        Ice(const Ice& ref);
        ~Ice();
        Ice& operator=(const Ice& ref);
};
~~~

- Ice를 추가하는 것 자체는 어려운 일이 아니다. 그런데 `Character`가 Ice를 새롭게 배우기 위해서는 코드에 변화가 있어야 한다. 기존의 `equip, unequip, use`는 Cure 스펠만을 상정한 채 설계되었기 때문이다. 이런 식으로 바꿀 수 있을지도 모르겠다.

~~~c++
class Character
{
    private:
        std::string name;
        Cure*    c;
        Ice*     i; // 추가됨
    public:
        // ... implementation
        void equipCure(Cure* c);
        void unequipCure();
        void useCure(std::string target);

        // 추가됨
        void equipIce(Ice *i);
        void unequipIce();
        void useIce(std::string target);
};
~~~

- `Character`는 `Cure` 이외에 `Ice`를 위한 새로운 멤버 변수를 가져야 할 것이다. 또한 Cure 만을 상정한 `equipCure, unequipCure, useCure` 이외에, Ice를 받을 수 있는 새로운 함수 ice 시리즈(`equipIce, unequipIce, useIce`)를 만들어야 할 것이다. 

- 코드 줄이 늘어나는 것이 별로 유쾌한 광경은 아니다. 뿐만 아니라 이런 식으로 코드가 변경되면, 이 프로그램은 **개방 폐쇄의 원칙(Open Close Principle)을 위배하게 된다.**

- **개방 폐쇄의 원칙(OCP)이란 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계가 되어야 한다는 원칙을 말한다.** 보통 OCP를 확장에 대해서는 개방적(open)이고, 수정에 대해서는 폐쇄적(closed)이어야 한다는 의미로 정의한다. 이 말은 Ice를 추가했을 때, 기존의 Character 클래스가 수정되어서는 안된다는 것이다.

- 아까 Character 클래스의 `void equip(Cure *c)`를 기억할 것이다. **강한 결합은 이렇게 어떤 함수가 어떤 인자만을 매개 변수로 받아들이는 것이다.** 강한 결합으로 구현된 객체는 매개 변수를 교체하기가 어렵고, 확장성이 매우 떨어진다. **Ice 이외에 수많은 Spell들이 추가될 수 있는데, 클래스 간의 결합이 강한 결합으로 이루어져 있으면 이런 식으로 각자의 장비, 사용 함수들을 일일히 구현해야 할 것이다. 이는 매우 비효율적인 행위이다.** 문제를 해결해보자.

### 재사용 가능한 추상 클래스 AMateria와 약한 결합(Loose Coupling) 

- c++ 코드의 재사용성에 대한 이야기는 상당히 프로페셔널한 부분이어서, 여기서 자세히 다루기는 어려운 것 같다. 다만 여태까지의 모듈을 통해 배운 것으로 망라하건데, **추상 클래스 AMateria를 구현하고 Ice, Cure와 같은 Spell들로 하여금 AMateria를 상속하게 만듦(약한 결합)으로써 코드의 재사용성을 강화하고, OCP를 준수하도록 할 수도 있다. AMateria를 만들면서 약한 결합(Loose Coupling)에 대해서도 알아보자.** 

**<span style="color:lightcoral">AMateria</span>**
~~~c++
class AMateria
{
    protected:
        [...];
    public:
        AMateria(std::string const & type);
        [...]
        std::string const & getType() const; //Returns the materia type
        virtual AMateria* clone() const = 0;
        virtual void use(ICharacter& target);
};
~~~

- 이것이 subject에서 주어진 AMateria의 원형이다. 이걸 가지고 채워보자.

~~~c++
class AMateria
{
    protected:
        std::string type;
    public:
        // AMateria();
        AMateria(const AMateria& ref);
        virtual ~AMateria();
        AMateria& operator=(const AMateria& ref);

        AMateria(std::string const& type);

        std::string const &	getType() const;
        virtual AMateria* clone() const = 0;
        virtual void use(std::string target);
        // virtual void use(ICharacter& target);
};
~~~

- 예를 들어, 이렇게 채워볼 수 있을 것 같다. 맨 밑줄의 `virtual void use(ICharacter& target);`의 경우, ICharacter를 다룰 때 같이 다뤄보도록 하고, 우선 임시로 그 윗줄의 `virtual void use(std::string target);`으로 대신 써보자. 주석으로는 계속 써 줄 예정이다.

**<span style="color:green">Cure</span>**, **<span style="color:Aqua">Ice</span>**
~~~c++
// ...

#include "AMateria.hpp"

class Cure : public AMateria
{
    public:
        Cure();
        Cure(const Cure& ref);
        ~Cure();
        Cure& operator=(const Cure& ref);

        AMateria*	clone() const;
        void	use(std::string target);	
        //  void use(ICharacter& target);		
};

class Ice : public AMateria
{
    public:
        Ice();
        Ice(const Ice& ref);
        ~Ice();
        Ice& operator=(const Ice& ref);

        AMateria* clone() const;
        void	use(std::string target);	
        // void use(ICharacter& target);		
};
~~~

- 이제 Cure와 Ice는 AMateria를 상속한다. AMateria를 상속하게 된 만큼, 추상 클래스 AMateria의 가상 함수들을 오버라이딩 해야 할 것이다.

- Character 클래스에도 변화가 있다. Character는 더 이상 Cure와 같은 구체적인 클래스를 매개변수로 취하지 않는다.

**<span style="color:purple">Character</span>**
~~~c++
class AMateria;

class Character
{
    private:
        std::string name;    
        AMateria*    slot[4];
    public:
		Character(std::string name_);
		Character(const Character &ref);
		Character &operator=(const Character &ref);
		~Character();

        std::string const& getName() const;
        void equip(AMateria* m);
		void unequip(int idx);
		void use(int idx, std::string target);
};
~~~

- 스펠이 여러가지로 추가될 수 있다는 것을 감안하여, 이제 캐릭터는 AMateria 클래스 포인터의 배열 slot을 멤버 변수로 가진다. 캐릭터가 새로운 스펠을 장착할 때 AMateria 클래스 포인터의 배열을 하나씩 채우고 해제할 때 인덱스를 받아 포인터를 NULL로 돌린다. 사용할 때에도 인덱스를 받아 해당 스펠을 타겟에 사용한다.

### concrete class

- 정의한 모든 연산(operation)이나 일부 연산의 구현을 서브 클래스로 넘기는 추상 클래스(abstract class)나 객체의 연산에 대한 구현이 포함되어 있지 않고 정의만 존재하는 인터페이스를 통해 인스턴스를 만들 수 없다. 완성되지 않은 설계도를 가지고 제품을 만들 수는 없기 때문이다.

- **모든 연산에 대한 구현을 가지고 있는 클래스가 바로 concrete class이다. 추상 클래스가 아닌 클래스는 모두 concrete class라고 할 수 있다**. 정의한 모든 연산에 대한 구현을 가지고 있는 완전한 클래스이므로 우리는 이 클래스의 인스턴스를 만들 수 있다.


