---
layout: post
title: 'cpp_module_05'
description: >
    "CPP Module 05에 대하여"
category: 42cursus
tags: cppmodule
---

## CPP Module 05

- table of contents
{:toc}

> Repetition and Exceptions

> 난 if-else 보다는 try-catch가 편하던데...

### 참고

- try-throw-catch를 사용한 예외 처리에 대해 아주 자세히 공부하고 싶다면, [예외 처리](https://blog.naver.com/kks227/220404335069) 링크 참조.

## ex00: Mommy, when I grow up, I want to be a bureaucrat!

### 사용자 정의 exception 클래스 만들기

- 참고 글을 읽어보았다면, try-catch의 대략적인 사용법에 대해 알고 있을 것이다. 우리가 주목해야 할 부분은 **사용자 정의 클래스를 통해 throw() 할 수 있다는 사실**이다. 클래스를 생성하거나(Bureaucrat, Form 등), 등급을 조정할 때 발생하는 각 예외 상황에 대해 우리가 직접 사용자 정의 클래스를 만들고 예외 처리를 하는 것이 이번 모듈의 전체적인 과업이 되겠다.

- 사용자 정의 클래스를 만들기 위해 hpp 파일에 특별히 `<exception>`이라는 헤더를 포함시켜야 한다. exception 헤더는 C++ 표준 예외 클래스 `std::exception`을 정의한다. 이 클래스는 모든 표준 예외 클래스들의 기본 클래스이다. 즉, 우리가 만드는 모든 사용자 정의 예외 처리 클래스가 이 std::exception을 상속하게 된다는 말이다. 이 std::exception은 예외 처리 시 기본적인 메시지를 제공하기 위한 what() 멤버 함수를 가지고 있다. 이것은 예외가 발생했을 때 예외에 대한 설명을 반환한다. 코드를 만들며 살펴보도록 하자.

~~~c++
Bureaucrat::Bureaucrat(const std::string name, int grade) : name(name), grade(grade)
{
	if (grade < 1)
		throw Bureaucrat::GradeTooHighException();
	else if (grade > 150)
		throw Bureaucrat::GradeTooLowException();
}
~~~

- 위는 name과 grade를 받아 Bureaucrat 객체를 생성하는 생성자이다. 조건에 따라 예외를 던지는데, grade가 1미만이면 `Bureaucrat::GradeTooHighException();`을, grade가 150을 초과한다면 `Bureaucrat::GradeTooLowException();`을 던진다.

- 물론 GradeTooHighException과 GradeTooLowException은 Bureaucrat 클래스 내부에 정의된 사용자 정의 클래스이다. Bureaucrat.hpp에 위 클래스들을 정의해야 사용할 수 있을 것이다. 어떤 식으로 정의하면 될까?

~~~c++
// Bureaucrat.hpp
#pragma once

# include <iostream>
# include <string>
# include <exception> // exception 헤더가 필요하다고 했다.

class Bureaucrat
{
    private:
        const std::string   name;
        int grade;
    public:
        // ... OCCF나 Getter, Setter들

        class GradeTooHighException : public std::exception
        {
            public:
                const char *what() const throw(); 
        };

        class GradeTooLowException : public std::exception
        {
            public:
                const char *what() const throw();        
        };

        // throw() is Dynamic Exception Specification, 
        // we can expect that this function will not occur 
        // any type of exception explicitly.
}
~~~

- 사용자 정의 예외 처리 클래스를 정의하기 위해 exception 헤더를 정의했다. 우리가 정의하는 예외 처리 클래스들은 std::exception을 상속하며, 그 기능(`what()`)을 사용하여 예외 처리를 할 수 있다. public 아래에 `GradeTooHighException`와 `GradeTooLowException` 클래스를 정의해놓았다. 한 가지 신경쓰이는 점이 있다. **클래스 내부에 다른 클래스를 정의해놓아도 될까?**

- 물론 문제될 것이 없다. 따로 써서 가독성을 향상시켜볼 수도 있겠지만, 제출 파일에 달리 exception에 대한 hpp 파일을 따로 지정해주지 않았으므로 class에서 사용할 예외 처리 클래스는 각자 class 내에 내부 클래스로 구현해보도록 하자.

### what()
- std::exception에는 아래와 같이 정의되어 있다.

~~~c++
// exception
class _LIBCPP_EXCEPTION_ABI exception
{
    public:
        _LIBCPP_INLINE_VISIBILITY exception() _NOEXCEPT {}
        virtual ~exception() _NOEXCEPT;
        virtual const char* what() const _NOEXCEPT;
};
~~~ 

- `virtual const char* what()`은 exception에 정의된 가상 함수 메서드로, std::exception을 상속한 사용자 정의 클래스에서 오버라이드 될 수 있다. `what()`은 발생한 Exception 객체의 종류를 문자열로 정의한다. 예를 들어 `GradeTooHighException`의 what()은 다음과 같이 정의될 수 있다.

~~~c++
const char* Bureaucrat::GradeTooHighException::what(void) const throw()
{
	return ("Grade is too high...");
}
~~~

- Bureaucrat 프로그램이 진행되다가 GradeTooHighException 예외가 발생했을 경우, what()이 호출되며 사용자는 GradeTooHighException 예외가 발생했다는 것을 알 수 있다.

<center><img src="/assets/img/cpp_module/05-grade-too-high.png" width="80%" height="80%"></center><br>

### 예외 사양(Exception Specification)

~~~c++
const char *what() const throw();
~~~

- 각 exception 클래스의 what이 위와 같이 정의되어 있는 것을 확인할 수 있을 것이다. 저 옆에 `throw()`는 무슨 의미일까? 저 throw는 **예외 사양(Exception Specification)**이라고 하며, 함수가 던질 수 있는 예외의 종류를 명시한다. 예를 들어

~~~c++
void myfunc1(int n) throw(std::runtime_error, std::logic_error);
~~~

- 위 코드에서 `myFunction()`에서는 std::runtime_error나 std::logic_error, 혹은 이들의 파생 클래스로 예외를 던질 수 있다.

~~~c++
void myfunc2(int n) throw();
~~~

- 함수 func_2 자체에서는 예외를 던지지 않는다는 것을 나타낸다. 이런 식으로 함수 원형이나, 정의부에 기재된 예외 사양을 통해 함수가 어떤 형태의 예외를 던지는 지 알 수 있다.

- 그러나 C++11 이후 버전에서 throw()를 사용한 예외 사양은 중요성을 잃었고, C++17에 이르러서는 더 이상 throw()로 예외 사양을 확인하지 않는다. 대신, noexcept를 사용하여 예외가 발생하지 않는다는 것을 명시한다. 현대 c++ 문법으로 `GradeTooLowException` 클래스를 정의하자면 아래와 같을 것이다.

~~~c++
class GradeTooLowException : public std::exception
{
    public:
        const char* what() const noexcept override;
};
~~~

- noexcept를 통해, what() 함수 자체로는 어떠한 예외도 발생시키지 않는다는 점을 알 수 있고, override를 통해 이 함수가 `std::exception::what()`을 오버라이드했다는 점을 알 수 있다. c++98에서 보다 직관성이 뛰어난 것 같다고 생각한다. ~~요즘 세상에 누가 std++98로 코딩하나요~~.

## ex01: Form up, maggots!

- Bureaucrat의 `GradeToo...` 예외 클래스들을 제대로 구현했다면, Form의 예외 클래스들 또한 무리 없이 구현할 수 있다. 예외 클래스들을 구현하고, `beSigned()`나 `signForm()`과 같은 함수들도, Form과 Bureaucrat의 관계를 생각하며 구현해보자.

## ex02: No, you need form 28B, not 28C...

- 만들어야 할 클래스와 함수들이 급격하게 늘어나서 좀 당혹스러울 수도 있다. 원래 만들어두었던 Form을 추상 클래스 AForm으로 바꾸고, 그 AForm을 상속하는 3가지 형태의 파생 Form `ShrubberyCreationForm`, `RobotomyRequestForm`, `PresidentialPardonForm`을 만들어야 한다. ShrubberyCreationForm이 조금 헷갈릴 수 있는데, 예전에 모듈 1에서 파일 열고 문자열 수정한 사본을 만들었던 기억을 되짚어보면 감이 좀 올지도 모른다. RobotomyRequestForm의 경우 랜덤 값을 받아야 하는데, c 함수를 사용해도 상관없다. `rand()` 혹은 `time()` 등등을 사용할 수 있을 것 같다. 방법은 자유다. PresidentialPardonForm은 그냥 통보만 해주면 되는 어렵지 않은 함수다. 

- Bureaucrat과 Form들의 관계를 생각하며, `execute(Bureaucrat const & executor)`나 `executeForm(Form const & form)` 등의 함수들도 구현해보자.

### const cast

- const_cast는 포인터 또는 레퍼런스의 상수성을 잠깐 제거해주는데 사용한다.
- const 변수를 바꾸는 const cast, 사용을 자제하는 편이 좋다고 한다. 그러나 과제를 원활하게 하기 위해 사용하였다.
- 본질적으로 값을 바꾸는 것이 아니라, 임시적으로 매핑하는 형식으로 작동한다. (즉, 상수성을 제거한 다른 포인터를 만들어 그 값을 변경해도, 원본의 값은 변경되지 않는다는 것, 정리 3번 참조) **(주소를 공유하고, 원본의 값을 변경하지 않으면서 객체로 접근할 수 있는 non-const한 방법을 추가하는 것으로 볼 수 있다)**

## ex03: At least this beats coffee-making
