---
layout: post
title: 'cpp_module_09'
description: >
    "CPP Module 09에 대하여"
category: 42cursus
tags: cppmodule
---

## CPP Module 09

- table of contents
{:toc}

> STL

> 이제 당신도 c++ 잘알

## ex00: Bitcoin Exchange

> 김해 제육 청년 김찬호 선생님 화이팅!!

### 개요

- 특정 일자의 비트 코인 가격을 출력하는 프로그램을 만들어야 한다.

- 프로그램은 **비트 코인의 일자별 가격이 적혀 있는 .csv 파일로 주어지는 데이터 베이스**를 사용해야 한다. 이 데이터베이스는 서브젝트에서 제공된다.

- 프로그램은 input 파일로 **두 번째 데이터 베이스**를 받는데, 그 데이터 베이스 안에는 평가할 일자와 가격이 제시되어 있다.

---

**프로그램이 따라야 할 규칙이 있다**

(1) 프로그램 이름은 **btc**여야 한다.

(2) 파일을 인자로 받아야 한다.

(3) 그 파일은 "date \| value" 의 형식으로 이루어져 있어야 한다.

(4) 적절한 일자는 언제나 "Year-Month-Day" 의 형식을 따라야 한다.

(5) 적절한 value는 0과 1000 사이의 float 혹은 양의 정수이다.

- **이번 모듈에서 각 exercise를 진행할 때, 최소한 하나의 컨테이너(STL Container)를 사용해야만 한다. 또한 발생할 수 있는 에러에 대해 적절한 메세지를 출력해야만 한다.**

---

- 서브젝트에서 프로그램이 받을 두 번째 데이터 베이스 `input.txt`의 예시를 보여준다. 아래와 같다.

~~~md
$> head input.txt
date | value
2011-01-03 | 3
2011-01-03 | 2
2011-01-03 | 1
2011-01-03 | 1.2
2011-01-09 | 1
2012-01-11 | -1
2001-42-42
2012-01-11 | 1
2012-01-11 | 2147483648
$
~~~

- "date \| value" 로 구성되어 있는 모습, value는 들쑥날쑥한데, 적절한 예외 처리를 해야 할 것이다.

- **프로그램은 input.txt의 일자에 맞는 Bitcoin의 value에, data.csv에 주어진 일자에 맞는 Bitcoin의 exchange rate를 곱한 값을 표준 출력 해야 한다.** 이 또한 서브젝트에 예시가 주어져 있다.

~~~md
$> ./btc
Error: could not open file.
$> ./btc input.txt
2011-01-03 => 3 = 0.9
2011-01-03 => 2 = 0.6
2011-01-03 => 1 = 0.3
2011-01-03 => 1.2 = 0.36
2011-01-09 => 1 = 0.32
Error: not a positive number.
Error: bad input => 2001-42-42
2012-01-11 => 1 = 7.1
Error: too large a number.
$>
~~~

- 만약 input.txt에 주어져 있는 날짜가 data.csv에 없다면, input.txt의 날짜와 가장 가까운 날을 고르되, input.txt의 날짜를 넘지는 말아야 한다. 이건 예시를 보면 알 수가 있다. 당장 data.csv에 2011년 1월 3일의 비트 코인 exchange rate는 주어져 있지 않은데, input.txt를 보면 2011년 1월 3일에 3개의 bitcoin value가 주어져 있다. data.csv에서 11년 1월 3일과 가장 가까운 날인데, 11년 1월 3일을 넘지 않는 날짜는 11년 1월 1일인데 data.csv에 책정된 11년 1월 1일의 bitcoin exchange rate는 0.3이다. 그래서 3과 0.3을 곱한 0.9를 출력한다. 나머지도 마찬가지다. input.txt의 11년 1월 9일도 data.csv에는 없어서, 적절한 날짜인 11년 1월 7일의 rate를 value에 곱해 출력한다(0.32). 그 외의 에러는 따로 메세지를 출력한다. 

- 이게 프로그램 구동 예시 위에 `The following is an example of the program’s use` 라는 말이 써져 있어서 그냥 예시 정도로 생각해도 될 법한데, 사실 이것 그대로 구현하는게 마음이 편하다. 본인은 처음에 이 예시를 유심히 보지 않고 Error가 발생했을 때 exception을 던져서 그 즉시 프로그램을 return하도록 짰는데, 출력이 이 예시랑 너무 달라져서 한번 갈아엎었었다.

**이번 ex에서 사용한 STL Container는 이후 ex들에서는 사용할 수 없다!**

### 문자열 스트림, std::stringstream

- 이번 모듈 전체를 관통하는 주제인 문자열 스트림이다. cpp module은 c++98만을 사용하도록 제한되어 있어, 문자열 파싱에 유용한 c++11의 스트링 변환 함수(stoi, stof, stod)를 사용할 수가 없다(**단, c 함수인 std::strtod는 사용할 수가 있다.**). **따라서 직접 스트림 변환을 해줘야 한다.** 예시 코드를 살펴보자.

~~~c++
#include <iostream>
#include <sstream>
#include <string>
using namespace std;

int main() 
{
    stringstream iss("test 123 aaa 456");

    string s1, s2;
    int i1, i2;

    iss >> s1 >> i1 >> s2 >> i2; 
    // 공백 혹은 개행을 기준으로 문자열을 parsing하고, 변수 형식에 맞게 변환

    cout << s1 << ' ' << i1 << ' ' << s2 << ' ' << i2 << endl;

	cout << sizeof(s1) << ' ' << sizeof(i1) \
		<< ' ' << sizeof(s2) << ' ' << sizeof(i2) << endl;
}
~~~

~~~md
❯ ./a.out
test 123 aaa 456
24 4 24 4
~~~

- `istringstream iss`를 선언하고 string인 `test 123 aaa 456`으로 초기화했다. stringstream은 문자열을 마치 스트림처럼 다룰 수 있도록 해주기 때문에, iss를 통해 파일에서 스트림(cin, getline 등)으로 입력받는 것 처럼 string의 내용을 입력받을 수 있도록 만들어준다. 뿐만 아니라 입력받을 때 변수의 자료형을 정해주면, 그 형식에 맞도록 자동으로 변환된다. 이는 상당히 강력한 기능이다.

- 위 코드에서 s1, s2는 string, i1, i2는 int로 선언되었고, stringstream으로 문자열 변환을 마친 후 각 변수의 size를 출력하면 형식에 맞게 변환되어있다는 사실을 알 수가 있다. 스트림 변환을 통해 data.csv와 input.txt를 편리하게 파싱할 수 있다.

### 없는 날짜 고르기

- input.txt의 날짜가 data.csv에 존재하지 않는다면, 가장 가까우면서도 그 input.txt의 날짜를 넘지 않는 data.csv의 날짜를 꼽아서 그 exchange rate에 input.txt의 value를 곱해서 출력해야 한다. 이는 `std::lower_bound()`를 통해 구현할 수가 있다. 알고리즘 문제를 풀면서 **이분 탐색**에 대해 공부한 적이 있다면 익숙한 함수일 것이다. `std::lower_bound`와 `std::upper_bound`에 대해 공부해보려면 아래 링크 참조

(1) 모두의 코드, [C++ 레퍼런스 - std::lower_bound 와 upper_bound (algorithm)](https://modoocode.com/298)

- lower_bound와 upper_bound는 lower와 upper라는 단어 때문에 마치 찾으려는 값이 컨테이너에 존재하지 않는다면 각각 찾으려는 값에 가장 근접하면서 작은 요소의 반복자, 가장 근접하면서 큰 요소의 반복자를 반환할 것 같은 착각을 일으키지만 lower_bound는 찾으려는 값보다 같거나 큰 값의 반복자를 반환하고, upper_bound는 찾으려는 값을 처음 초과하는 지점의 반복자를 반환한다. 따라서 문제의 의도대로 날짜를 찾기 위해서는 lower_bound를 사용하여 날짜와 가장 가까운 다음 날의 날짜를 찾은 후, 반복자를 하나 빼서 찾으려는 날짜보다 이전의 날짜로 조정해야 한다. 또, input의 날짜가 data.csv의 날짜보다 너무 이르거나 너무 멀거나 해서 생기는 오류들도 따로 처리해야 한다.

### data.csv 파싱에 관하여

- 과제를 구현하면서 생각해봤던 이슈다. data.csv는 대략

~~~md
date,exchange_rate
2009-01-02,0
2009-01-05,0
2009-01-08,0
2009-01-11,0
2009-01-14,0
2009-01-17,0
...
~~~

- 이런 형식으로 이루어져 있는데, 이걸 파싱해야하냐 말아야하냐는 거다. 본인은 파싱하긴 했다. ".csv" 같은 파일 확장자 뿐만 아니라, 라인별로 파싱을 해줬다. 그런데 data.csv는 과제에서 제공해주는 파일인데 이걸 파싱했어야 했나? 하는 것이다. data.csv를 파싱한다는 것은 평가자가 data.csv의 확장자를 바꾸는 것 이외에 data.csv를 변조한다는 것을 전제하는 건데, 평가하는 과정에서 그 정도까지의 검증이 필요하지 않다고 생각하기 때문에 data.csv를 파싱하는 것에 대해 의문을 가지고 되었다. 물론 input.txt를 파싱했다면 그 로직을 그대로 가져오면 되기 때문에, 찝찝하다면 data.csv도 파싱을 해주면 되겠다.

## ex01: Reverse Polish Notation

- 후위 표기법을 구현해보는 과제이다. 태생이 문과인 나는 접해본 적이 없는 계산법이지만, 대략 컴퓨터가 연산을 쉽게 하도록 표현하는 방법이라고 한다. 우리가 평소에 사용하는 중위 표기법과 달라 이질적이지만, 알고리즘을 통해 스택 문제들을 접해보았다면 아주 낯설지는 않을 것 같다.

- 마찬가지로 stringstream을 기깔나게 쓸 수 있는 문제이다. stringstream과 strtod를 사용하면 손쉽게 수식을 double과 operator로 파싱할 수 있다.

- 수식을 파싱하여 숫자라면 스택에 추가하고, 연산자라면 스택에서 숫자를 제거하여 해당 연산을 수행한 이후 다시 스택에 넣는다. 모든 연산이 끝난 후에는 스택에 최종적인 연산의 결과값만이 남아있어야 한다. 연산자 하나에 스택의 top의 원소와 그 아래 숫자의 연산이 실행되고 그 결과값이 다시 스택에 push되기 때문에, 숫자의 개수는 연산자의 개수보다 하나가 많아야 한다. 이것을 체크하기 위해 연산자가 들어왔을 때 최소한 스택의 숫자가 2개 들어있는지, 모든 연산이 실행되었을 때 스택의 size가 1인지 등을 체크해야 할 것이다.

- 알고리즘 문제를 푸는 것 같아서 흥미로운 exercise였다. 또 괄호를 구현할 필요가 없어서 난이도가 아주 높지는 않았다. 괄호를 구현해야했다면 더 까다로운 exercise가 되었을 것이다. 

## ex02: PmergeMe

- 양의 정수 시퀀스 컨테이너를 매개 변수로 받아서, 병합-삽입 정렬을 사용하여 정렬하는 프로그램 PmergeMe를 구현해야 한다.

- 꼭 집어 말하자면, 포드-존슨 알고리즘을 사용해야 한다. 

---

!주의!

- 본인은 이 exercise를 재귀를 사용해서 풀지 않았다. 본인이 과제를 통과할 때는 내가 사용한 방법이 딱히 틀리다고 생각하지 않았는데 지금 와서 보면  

---