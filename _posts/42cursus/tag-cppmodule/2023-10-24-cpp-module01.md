---
layout: post
title: "cpp_module_01"
description: >
    "CPP Module 01에 대하여"
category: 42cursus
tags: cppmodule
---

## CPP Module 01

* table of contents
{:toc}

> Memory allocation, pointers to members, references, switch statement

> C++의 메모리 할당, 포인터와 멤버들, 참조들, switch문 ... C++에서도 메모리 관리는 계속된다.

## ex00 BraiiiiiiinnnzzzZ

- Zombie 클래스를 만들어야 한다. string 멤버 변수 name을 가지고, `void announce(void)`라는 멤버 함수를 가진다. 좀비는 announce 하면서

~~~md
    <name>: BraiiiiiiinnnzzzZ...
~~~

  라고 한다. name을 출력할 때, "<", ">"(brackets)는 제거해야 하는데 이는 42의 유구한 전통이다. 고사기에도 그렇게 적혀있다.

- 그리고 함수를 2개 만들어야 한다. `Zombie* newZombie(std::string name)`과 `void randomChump(std::string name)`이라는 녀석들이다.

  (1) 첫 번째 `newZombie(string name)`는 좀비를 만들어서 이름을 붙이고 **함수의 스코프 바깥에서 사용할 수 있도록 반환**하는 것이다. 매우 매우 중요한 포인트

  (2) 두 번째 `randomChump(string name)`는 좀비를 만들어서 이름을 붙이고 좀비가 annouce하면 된다. 이상 무.

### 함수 스코프 바깥에서 사용할 수 있도록 반환

- 중요해서 한번 더 적었다. 이게 무슨 소리일까? 아래 코드를 한번 보자. 출력값은 굳이 안적었다. 출력값이 중요한 코드가 아니다.

~~~c
#include <stdio.h>

int *getStackPtr() {
    int var = 42;
    int *ptr = &var; // 스택에서 할당된 포인터를 함수 스코프 밖으로 빼려고 함
    return ptr;
}

int main() 
{
    int *ptr = getStackPtr();
    printf("%d\n", *ptr); 
    return 0;
}
~~~

- 이런 식으로 쓰는 코드는 본 적이 없을 것이다. 당연하다. 이런 코드를 적는 자들은 모두 닌자들에게 살해당했기 때문이다...

- `getStackPtr()`를 보면 스택에 int 변수 하나를 할당하고, 포인터에 그 주소를 담아서 반환한다. 그런데 var은 지역 변수이기 때문에 스코프가 getStackPtr()를 벗어나는 순간 해제되고, ptr의 주소는 해제된 곳을 가리키게 된다. 즉 ptr은 **댕글링 포인터**가 된다. 댕글링 포인터(Dangling Pointer)는 이미 해제된 메모리를 가리키거나 더 이상 유효하지 않은 메모리 위치를 가리키는 포인터다. 이는 프로그램의 안정성과 예측 가능성을 저해하며, 예기치 않은 동작 또는 프로그램 충돌을 유발한다고 한다. **그러니까 만약 이런 식으로 `Zombie*`를 반환하면, 그게 함수 스코프 바깥에서 사용할 수 없도록 반환하는 거다.** 이러면 안 된다. 