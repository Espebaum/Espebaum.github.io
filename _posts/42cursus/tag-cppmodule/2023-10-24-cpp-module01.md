---
layout: post
title: "cpp_module_01"
description: >
    "CPP Module 01에 대하여"
category: 42cursus
tags: cppmodule
---

## CPP Module 01

* table of contents
{:toc}

> Memory allocation, pointers to members, references, switch statement

> C++의 메모리 할당, 포인터와 멤버들, 참조들, switch문 ... C++에서도 메모리 관리는 계속된다.

## ex00 BraiiiiiiinnnzzzZ

- Zombie 클래스를 만들어야 한다. string 멤버 변수 name을 가지고, `void announce(void)`라는 멤버 함수를 가진다. 좀비는 announce 하면서

~~~md
    <name>: BraiiiiiiinnnzzzZ...
~~~

  라고 한다. name을 출력할 때, "<", ">"(brackets)는 제거해야 하는데 이는 42의 유구한 전통이다. 고사기에도 그렇게 적혀있다.

- 그리고 함수를 2개 만들어야 한다. `Zombie* newZombie(std::string name)`과 `void randomChump(std::string name)`이라는 녀석들이다.

  (1) 첫 번째 `newZombie(string name)`는 좀비를 만들어서 이름을 붙이고 **함수의 스코프 바깥에서 사용할 수 있도록 반환**하는 것이다. 매우 매우 중요한 포인트

  (2) 두 번째 `randomChump(string name)`는 좀비를 만들어서 이름을 붙이고 좀비가 annouce하면 된다. 이상 무.

### 함수 스코프 바깥에서 사용할 수 있도록 반환

- 중요해서 한번 더 적었다. 이게 무슨 소리일까? 아래 코드를 한번 보자. 출력값은 굳이 안적었다. 출력값이 중요한 코드가 아니다.

~~~c
#include <stdio.h>

int *getStackPtr() {
    int var = 42;
    int *ptr = &var; // 스택에서 할당된 포인터를 함수 스코프 밖으로 빼려고 함
    return ptr;
}

int main() 
{
    int *ptr = getStackPtr();
    printf("%d\n", *ptr); 
    return 0;
}
~~~

- 이런 식으로 쓰는 코드는 본 적이 없을 것이다. 당연하다. 이런 코드를 적는 자들은 모두 닌자에게 살해당했기 때문이다...

- `getStackPtr()`를 보면 스택에 int 변수 하나를 할당하고, 포인터에 그 주소를 담아서 반환한다. 그런데 var은 지역 변수이기 때문에 스코프가 getStackPtr()를 벗어나는 순간 해제되고, ptr의 주소는 해제된 곳을 가리키게 된다. 즉 ptr은 **댕글링 포인터**가 된다. 댕글링 포인터(Dangling Pointer)는 이미 해제된 메모리를 가리키거나 더 이상 유효하지 않은 메모리 위치를 가리키는 포인터다. 이는 프로그램의 안정성과 예측 가능성을 저해하며, 예기치 않은 동작 또는 프로그램 충돌을 유발한다고 한다. **그러니까 만약 이런 식으로 `Zombie*`를 반환하면, 그게 함수 스코프 바깥에서 사용할 수 없도록 반환하는 거다.** 이러면 안 된다. 그러면 함수 스코프 바깥에서 사용할 수 있도록 반환한다는 건 뭘까? 우리는 이미 답을 알고 있다. 수백번도 넘게 해온 행위이다. 바로 **메모리의 동적 할당(malloc, calloc ...)이다.**

** 스택과 힙에 대해 자세히 알고 싶다면 [C++ 08.10 - 스택과 힙 (Stack and Heap)](https://boycoding.tistory.com/235) 참고

- 동적 할당과 스택에 포인터를 만드는 것의 차이에 대해 공부한 적이 있을 것이다. 메모리를 동적 할당하면 메모리 세그먼트(스택, 힙, 코드, 데이터) 중에서는 힙을 쓰게 되며, 스택에 비해 더 큰 메모리를 가져갈 수 있지만 속도가 느리고, 명시적으로 해제할 때까지 유지되고, 포인터를 역참조하여 value에 접근할 수 있다. 여기에 더해 중요한 포인트가 바로 **메모리를 직접 제어할 수 있기 때문에 데이터를 함수 스코프 밖으로 끄집어 낼 수 있다**는 점에 있다. 즉 함수 스코프 바깥에서 사용할 수 있도록 반환할 수 있다. **이 과제는 메모리를 동적으로 할당할 것을 요구한다.**

### newZombie(std::string name)

~~~c++
#include "Zombie.hpp"

Zombie	*newZombie(std::string name)
{
	Zombie	*heap = new Zombie(name);
	return (heap);
}
~~~

- 문자열 name을 매개변수로 받아 새로운 좀비 클래스 하나를 동적 할당하여 스코프 바깥으로 반환하는 코드이다. 간단명료 그 자체.

- C++에서는 malloc 대신 new를 사용한다. 쪼금만 살펴보자면 대략 이렇게 생겼다.

~~~c++
void* operator new ( std::size_t count );
~~~

- 또한 세부적으로는 아래와 같다.

~~~c++
void* operator new(std::size_t sz)
{
    std::printf("1) new(size_t), size = %zu\n", sz);
    if (sz == 0)
        ++sz; // avoid std::malloc(0) which may return nullptr on success
 
    if (void *ptr = std::malloc(sz))
        return ptr;
 
    throw std::bad_alloc{}; // required by [new.delete.single]/3
}
~~~

** 출처, [CPP Reference, operator new, operator new[]](https://en.cppreference.com/w/cpp/memory/new/operator_new)

- **내부적으로 malloc을 사용**하고, 에러 발생 시에는 exception을 던진다. 예외 처리의 일종이라고 생각하자. 이 과제에서는 사용하지 않는다.

### 생성자와 소멸자

- 생성자와 소멸자가 무엇인지에 대해서 굳이 나열하진 않겠다. 중요한 점은 **결국 클래스를 생성할 때는 생성자가, 클래스가 없어질 땐 소멸자가 반드시 호출된다는 것이다.** 뭐 당연한 소리를 하냐고 볼 수도 있겠지만 **반드시**가 가지는 힘이 상당히 강력하다. 우리가 변수를 선언하면 초기화가 필요하다는 사실을 알면서도, 또 메모리를 동적 할당하면 해제가 필요하다는 사실을 알면서도, C에서 그 많은 segmentation fault와 data leaks를 목격했던 이유가 바로 저 "반드시"의 부재에 있다. 내가 생각하는 생성자와 소멸자의 강력한 힘은 그 자체가 **초기화와 해제**에 관한 명시적인 course라는 점에 있다.

> 돌다리를 두들겨보고 건너는 것과 그냥 건너는 것은 꽤나 차이가 크다고 볼 수 있다...

- 클래스의 존재와 그 특징들은 상속/다형성과 더불어 C++가 가지는 **뚜렷한 특징**인데, 여기서는 C의 구조체와 C++의 클래스에 대해 조금만 이야기해보도록 하겠다.

#### (1) 멤버 함수

- 구글링을 하면서 막 찾아보다가 C 구조체로 C++의 클래스를 흉내내는 코드를 본 적이 있다(시간나면 한번 해보는 것도 나쁘지 않을 것 같다). 역시 C 구조체와 C++ 클래스의 가장 눈에 띄는 차이는 **멤버 함수**일 것이다. C 구조체에는 함수 자체를 담을 수는 없으며, 비슷한 걸 흉내내려면 함수 포인터를 써야한다. 아래는 내가 C 구조체로 C++ 클래스를 흉내냈던 코드다.

~~~c
struct c_Person
{
	char* name;
	int		age;

	int(*getAge)(c_Person *);
	void(*setAge)(c_Person *, int);
	string(*getName)(c_Person *);
	void(*setName)(c_Person *, string);
};
~~~

~~~c++
class Person 
{
	private:
		string	name;
		int		age;
	public:
		Person();
		Person(string name, int age);
		string Getname() const;
		int	GetAge() const;
		void SetName(string name);
		void SetAge(int age);
		~Person();
};
~~~

- 이렇게 보면 둘이 비슷해 보일지도 모르겠다. 어차피 함수 내부 구현하는건 똑같을텐데 C도 그냥 `getAge()`, `setAge()`, `getName()`, `setName()` 구현해서 매칭해주면 되는거 아닐까하고 생각할수도 있다. 물론 구조체, 클래스를 하나만 쓸거면 크게 상관없을거다. 사람이 천 명이면 어떨까? 구조체 천 개에 일일히 함수 매칭해주고, 구조체 포인터 보내서 이름, 나이 일일히 초기화할 거 생각하면 벌써부터 군침이 싹돈다. 재사용성이 아주 엉망이다. 반면에 클래스는 그렇지 않다. 클래스 안의 멤버 함수들은 클래스가 생성되면서 단 한번만 생성된다. 이후 저 클래스로 만들어진 객체들은 동일한 함수 포인터들을 돌려쓴다. 함수를 일일히 매칭해줄 필요가 없다. 또 생성자 오버로딩을 통해 멤버 변수들을 명시적으로 초기화할 수 있다. 실수가 발생할 확률이 적다는 거다. 적어도 char*로 된 이름 천 개 할당하면서 생기는 실수보다는 훨씬 적을 것 같다.

#### (2) this 포인터

- 이건 또 클래스가 지닌 특별한 기능이다. 기능에 대한 상세한 내용을 알고 싶다면 [C++ 09.10 - this 포인터](https://boycoding.tistory.com/250)을 참고하자. this 포인터는 자기 자신에 대한 포인터인데, 컴파일러 상에서 항상 멤버 함수의 매개 변수에 추가된다. 예를 들어 Person의 age를 반환하는 `int getAge()`에 대해 생각해보자.

~~~c++
int	Person::getAge(const Person* this) const
{ // int Person::getAge() const
	return (this->age);
}
~~~

- 매개 변수에 포함된 `const Person* this`가 바로 this 포인터이다. 우리가 작성하는 코드 상에서는 등장하지 않지만, 컴파일러 단에서 추가되어 객체를 식별한다. 똑같이 getAge()를 호출하더라도, 객체가 다르면 다른 값을 반환할 수 있는 비결이다.

## ex01: Moar brainz!

- 이번 exercise는 객체 배열의 동적 할당과 관련이 있다. 단도직입적으로 객체 배열을 생성하는 요령에 대해 알아보자.

#### 객체 배열의 선언 및 초기화

~~~c++
Classname*  ptr = new Classname[size];
~~~

- 이걸 Zombie에 대입시켜보면?

~~~c++
Zombie* arr = new Zombie[size];
~~~

- 이렇게 하면 size만큼의 Zombie 배열을 얻을 수 있다. 다만 c++98에서 이런 식으로 객체 배열을 선언할 때는 **매개 변수가 있는 생성자를 호출할 수가 없다(c++11부터 제한적으로 가능하다고 한다).** 그 말인즉슨, 저렇게 선언된 Zombie 클래스 각각의 이름은 빈 문자열로 초기화 되어있고, 우리가 수동으로 이름을 초기화해주어야 한다는 거다. 반복문을 돌면서 알맞은 처리를 해주면 되겠다.

#### 객체 배열의 해제

- new로 선언했으니, delete로 해제하는 것도 동일하다. 그런데 해제하는 모양이 살짝 다르다. 아래와 같이 해제한다.

~~~c++
Zombie* arr = new Zombie[size];
...

delete[] arr;
~~~

- delete[]를 통해, 배열의 각 요소에 있는 소멸자들을 전부 호출할 수 있다. `delete arr`라고만 쓰면 배열의 첫 번째 원소의 소멸자만을 호출하게 될 것이다. 