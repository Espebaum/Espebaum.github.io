---
layout: post
title: "push_swap"
description: >
    "push_swap에 대하여"
category: 42cursus
tags: pushswap
---
## 배열로 push_swap 해보자! (5)

* table of contents
{:toc}
### < 목차 >
{:.lead}
[1. resize](#void-resizet_deque-d-int-new_cap)

[2. rotate]()

[3. reverse_rotate]()

## 명령어 함수

### void	resize(t_deque *d, int new_cap)

~~~c
void	resize(t_deque *d, int new_cap)
{
	int		*new_arr;
	int		idx;
	int		i;

	new_arr = (int *) malloc(sizeof(int) * new_cap);
	idx = 0;
	i = d->head - 1;
	if (d->head < d->tail)
		while (++i < d->tail)
			new_arr[idx++] = d->arr[i];
	else
	{
		while (++i < d->capacity)
			new_arr[idx++] = d->arr[i];
		i = -1;
		while (++i < d->tail)
			new_arr[idx++] = d->arr[i];
	}
	free(d->arr);
	d->arr = new_arr;
	d->head = 0;
	d->tail = idx;
	d->capacity = new_cap;
}
~~~

- 이전글의 [`push_back()`](https://espebaum.github.io/42cursus/push-swap-4.html#2-void--push_backt_deque-a-int-val)에서 resize하는 것을 살짝 보여줬었다. 여기서 자세하게 살펴보자. 우선 기존의 capacity의 2배에 해당하는 매개 변수 `new_cap` 만큼의 새로운 정수 배열을 할당한다.

~~~c
new_arr = (int *) malloc(sizeof(int) * new_cap);
~~~

- 이후, 원래의 배열에서 새로운 배열로 원소들을 하나씩 복사하는데, **여기서 분기가 2개로 나뉜다.**

#### (1) head < tail인 경우
~~~c
...
    i = d->head - 1; // 전위 연산을 하기 위해 -1을 함
    idx = 0;
...
	if (d->head < d->tail)
		while (++i < d->tail)
			new_arr[idx++] = d->arr[i];
...
~~~

- head가 tail보다 작은 경우는 간단하다. 우리가 평상시에 배열을 복사하는 것처럼 순서대로 하나씩 복사하면 된다. 