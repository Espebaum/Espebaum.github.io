---
layout: post
title: "push_swap"
description: >
    "push_swap에 대하여"
category: 42cursus
tags: pushswap
---
## 배열로 push_swap 해보자! (4)

* table of contents
{:toc}

## 명령어 함수

### (1) void  swap_top(t_deque *a)

~~~c
void	swap_top(t_deque *a)
{
	int		tmp;
	int		idx1;
	int		idx2;

	idx1 = a->head;
	if (idx1 == a->capacity - 1)
		idx2 = 0;
	else
		idx2 = idx1 + 1;
	tmp = a->arr[idx1];
	a->arr[idx1] = a->arr[idx2];
	a->arr[idx2] = tmp;
}
~~~

- 스택 a의 top에 있는 원소와, 그 다음 원소를 swap 한다. 앞서 우리는 `arr[head]`가 스택의 top에 있는 원소라는 것을 공부한 바 있다.
- **분기문**이 눈에 띈다. 마찬가지로 head가 capacity - 1일수도 있다. 아래를 보자.

~~~c
"t_deque* a의 정보"
  arr = {2, 3, 4, 5, 6, 7, -, ..., -, 1} // len, capacity = 32
         ↑                 ↑          ↑
     top + 1              tail    head(top) = capacity - 1

  capacity = 32;
  head = 31; // arr[31] = 1;
  tail = 6; // a[tail - 1] = 7;

  ** 추상화된 stack a -> {1, 2, 3, 4, 5, 6, 7} **
  스택 a의 size = 7 // {1, 2, 3, 4, 5, 6, 7}의 7개

"swap a 이후, t_deque* a의 정보"
  arr = {1, 3, 4, 5, 6, 7, -, ..., -, 2} // 1과 2의 위치가 바뀜
         ↑                 ↑          ↑
     top + 1              tail       head(top)

  capacity = 32;
  head = 31; // arr[31] = 2;
  tail = 6; // a[tail - 1] = 7;

  ** 추상화된 stack a -> {2, 1, 3, 4, 5, 6, 7} ** 
  스택 a의 size = 7 // {2, 1, 3, 4, 5, 6, 7}의 7개
~~~

- 스택 a의 top과 그 다음 원소를 swap하고 싶다. top은 arr[head]인데, 다음 원소는 배열 상에 존재하지 않는다. [지난 글](https://espebaum.github.io/42cursus/push-swap-3.html)에서 공부했다시피 이 경우, arr[head]의 다음 원소는 arr[0]이 된다. 배열이 처음과 끝이 이어진 원형 큐와 같이 작동하기 위해선 이와 같이 처리해야한다.

### (2) void  push_back(t_deque *a, int val)
~~~c
void	push_back(t_deque *a, int val)
{
	if (a->size == a->capacity)
		resize(a, a->capacity * 2); // void resize(t_deque *a, int new_cap)
	a->arr[a->tail++] = val;
	if (a->tail == a->capacity)
		a->tail = 0;
	a->size++;
}
~~~

- 구조체와 추가하고 싶은 value를 매개변수로 받아 스택의 bottom에 변수를 추가한다. arr[tail]에 변수를 추가하고(기존 배열은 arr[tail - 1]이 스택의 마지막 원소 bottom), tail을 1 더하고, size를 하나 늘리면 되겠다. **역시 capacity 끝처리를 잘해주어야 한다.** 앞으로 등장하는 명령어 함수에 있어서 이런 capacity 끝처리는 계속해서 등장한다. 물론 배열의 끝과 끝이 이어져있다는 것을 인지하고 있다면 아주 어려운 처리는 아니라고 생각한다.

- 맨 앞에 있는 resize 코드는 다음 글에서 다룰 텐데, capacity가 32인 경우에, arr[0]부터 arr[capacity - 1]까지 모든 배열의 원소가 가득 차 있어서 배열이 더 이상 숫자를 담을 수 없을 때 capacity를 64로 늘린 새로운 배열을 할당하고 기존 배열의 head, tail, size와 같은 정보를 옮겨담는 과정이 담겨있는 코드다. 우선 여기서는 capacity를 늘린다는 점만 염두해두도록 하자.

- arr[tail]에 val을 담고, tail에 1을 더했다. 이때 tail이 capacity인 경우에 대한 처리가 필요하다. capacity가 32인 경우, tail이 32면 배열 바깥으로 벗어나게 된다(arr[32], 32개짜리 배열의 마지막 인덱스는 arr[31]이다). 이 경우 tail을 0으로 바꿔주어야 한다. 이렇게 되면 tail - 1이 arr[31]을 가리키고 tail이 0인, 원형으로 이어진 배열 모양을 맞추게 된다.

- 예를 들어 capacity가 8이고, arr = {1, 2, 3, 4, 5, 6, 7, 8}인 배열을 담고 있는 스택 a를 생각해보자. **`arr[head]`는 1이고, `arr[tail - 1]`은 8이다. head와 tail은 둘다 0이다. 물론 head와 tail이 동일할 수 있다. 우리는 arr[head]부터 arr[tail - 1]까지를 스택으로 간주한다.** tail - 1이 7인데 왜 tail이 0인지 모르겠다면, 지난 글의 [`int back()`](https://espebaum.github.io/42cursus/push-swap-3.html#4-int-backt_deque-a)을 참고하자.

(예시)
~~~c
"t_deque* a의 정보"

capacity = 8;
arr = {1, 2, 3, 4, 5, 6, 7, 8}
       ↑                    ↑
      head             tail - 1
      tail
idx =  0  1  2  3  4  5  6  7
size = 8; // 스택 a의 사이즈
~~~
- 여기에 9를 push_back() 해보자. 먼저 9가 들어오면 원소의 개수가 capacity보다 많아지므로, capacity를 16으로 resize한다. 스택은 다음과 같이 바뀐다.

~~~c
"resize한 후, t_deque* a의 정보"
// resize(a, a->capacity * 2);
capacity = 16;
                              tail
                               ↓
arr = {1, 2, 3, 4, 5, 6, 7, 8, -, -, ... , -} 
       ↑                    ↑
      head             tail - 1
      
idx =  0  1  2  3  4  5  6  7  8  ...      15
size = 8; // 스택 a의 사이즈
~~~
- capacity가 8에서 16으로 바뀌어 새로운 원소를 받을 준비가 끝났다. 이후엔 tail을 하나 늘리고, 원소를 넣고, 사이즈를 늘리는 예의 처리를 진행한다. 9를 push_back 해보자.

~~~c
"예의 처리가 끝난 후의 t_deque* a의 정보"
// a->arr[a->tail++] = val;
capacity = 16;
                                 tail
                                  ↓
arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, -, ... , -} 
       ↑                       ↑
      head                tail - 1
      
idx =  0  1  2  3  4  5  6  7  8  ...      15
size = 9; // 스택 a의 사이즈, size++;
~~~
- 마지막엔 역시 `a->tail == a->capacity`인 경우에 대한 처리가 있다. 이때는 tail을 0으로 바꾼다.

###