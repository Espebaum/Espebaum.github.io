---
layout: post
title: "2023년 10월 28일"
category: diary
---

- 클러스터에 21시에 왔다. 난 시간을 초월했다. 

- <form action ="/api/post/new" method="POST"></form>
  => form 태그

~~~ts
export default async function handler(req, res) {
    if (req.method == 'POST') {
        if (req.body.title == '' || req.body.content == '') {
            // req.body.title & req.body.content
            return res.status(500).json('제목이나 내용을 적어주세요')
        }
        const client = await connectDB
        const db = client.db("forum")
        let result = await db.collection('post').insertOne(req.body)
        return res.redirect(302, '/list')
    }
}
~~~

- req.body에 form 내부의 title, content가 담겨있다.

- 챗찌피티를 활용해 만들어본 회원가입처리

~~~ts
// localhost:3000/join
export default function Join() {
    return (
        <div className="p-20">
            <h4>회원가입 하기</h4>
            <form action ="/api/post/account" method="POST">
                <input name="id" placeholder="아이디"/>
                <input name="password" placeholder="비밀번호"/>
                <button type="submit">제출</button>
            </form>
        </div>
    )
}

// /api/post/account
import { connectDB } from "@/util/database"

export default async function handler(req, res) {
    if (req.method == 'POST') {
        if (req.body.id == '' || req.body.password == '') {
            return res.status(500).json('아이디와 비밀번호를 둘 다 입력해야 합니다')
        }
        const client = await connectDB
        const db = client.db("forum")
        let catalog = await db.collection('accounts').find().toArray()

        const findId = catalog.find(user => user.id === req.body.id)
        // 신기술

        if (findId) {
            return res.status(500).json('이미 존재하는 id입니다')
        }
        let result = await db.collection('accounts').insertOne(req.body)
        return res.redirect(302, '/join')
    }
}
~~~

- Javascript find 함수 챗찌피티가 사용법을 알려줌

~~~md
해당 라인은 JavaScript의 Array.prototype.find 메서드를 사용하여 배열인 catalog에서 
조건을 만족하는 첫 번째 요소를 찾는 역할을 합니다.

여기서 catalog는 기존 사용자 정보가 담긴 배열이며, existingUser 변수는 조건에 맞는 사용자 정보를
저장할 변수입니다. find 메서드의 동작은 다음과 같습니다:

1) catalog 배열을 처음부터 끝까지 반복하면서,
2) 콜백 함수인 user => user.id === req.body.id를 각 요소에 대해 실행합니다.
3) 'user'는 배열 내의 각 요소를 나타냅니다. 이 함수는 user.id가 req.body.id와 같은지 비교합니다.
4) 만약 req.body.id와 일치하는 ID가 있는 경우, find는 해당 사용자 정보를 existingUser 변수에 할당하고, 
반복을 멈춥니다.
5) 만약 일치하는 ID를 찾지 못하면 existingUser는 undefined가 됩니다.
6) 결과적으로, existingUser에는 req.body.id와 일치하는 ID를 가진 사용자 정보가 존재하면 해당 정보가 저장되고 
그렇지 않으면 undefined가 저장됩니다. 이를 통해 코드는 입력한 ID가 이미 데이터베이스에 존재하는지 확인할 수 있습니다.
~~~

- 간단한 예시 코드
~~~ts
// 숫자 배열
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// 찾고자 하는 조건: 짝수인 첫 번째 숫자
const condition = (number) => number % 2 === 0;

// find 메서드를 사용하여 조건을 만족하는 요소 찾기
const foundNumber = numbers.find(condition);

if (foundNumber !== undefined) {
    console.log("조건을 만족하는 첫 번째 숫자:", foundNumber);
} else {
    console.log("조건을 만족하는 숫자를 찾지 못했습니다.");
}
~~~


~~~ts
import { connectDB } from "@/util/database"
import { ObjectId } from "mongodb"
import React from 'react'

export default async function Edit(props) {
    const client = await connectDB
    const db = client.db("forum")
    let result = await db.collection('post').findOne({ _id: new ObjectId(props.params.id) })

    return (
        <div className="p-20">
        <h4>글 수정하기</h4>
        <form action ="/api/post/update" method="POST">
            <input type="hidden" name="id" value={props.params.id} />
            <input name="title" defaultValue={ result.title } />
            <input name="content" defaultValue={ result.content } />
            <button type="submit">제출</button>
        </form>
    </div>
    )
}
~~~

- value, 박스에 원래 글 넣어놓기

~~~ts
<input type="hidden" name="id" value={props.params.id} /> 
~~~

 - hidden 값으로 id보내기, 박스로는 id랑 content밖에 전달할수가 없더라.

~~~ts
<input style={{ display : 'none' }} name="_id" value={ result._id.toString() } />
~~~

  - 아니면 이런 식으로 전달해도됨됨됨

- 클라이언트 컴포넌트에서 db데이터 받기
~~~ts
'use client'

import Link from 'next/link'

export default async function ShowPage() {

    useEffect(()=> {
        
    })

    return (
        result.map((a, i)=>{
            <div className="list-item" key={i}>
                <h4><Link prefetch={ false } href={ `/detail/${result[i]._id}`} >
                    { result[i].title }
                </Link></h4>
                <p> { Date() } </p>
            </div> 
        })
    )
}
~~~

- 검색엔진노출에 어려움을 겪을수있다.(props로 받는거보다)


~~~ts
export default async function List() {

    const client = await connectDB
    const db = client.db("forum")
    let result = await db.collection('post').find().toArray()

    result = result.map(item=>({ ...item, _id: item._id.toString() })) // 중요

    return (
        <div className="list-bg"> 
            <ShowPage result={ result } />
        </div>        
    )
}
~~~

- 나는 저기 중요하다고 주석친 코드가 없으면 어쩐지 문제가 생겼다. 아무래도 몽고디비의 id가 문자열이 아니라서 자식 컴포넌트에서 받아쓰기 어려운 부분이 있었나보다. item은 임의의 변수 이름이다.

- 원본 result 배열은 새로운 result 배열에 덮어씌워진다. 원본 result 배열을 갖고 있어야 하면 변수 이름을 다른 걸로 만들면 됨.

- form 태그를 통해 서버에 get, post 등의 요청 가능, ajax도 사용가능(클라이언트 컴포넌트만 사용가능)

- JSON.stringify({a:1})로 바디를 보내면(객체, array), api에서는 JSON.parse(req.body) 이런식으로 stringify를 풀어야 내부 value를 갖다쓸수있슴.

- fetch 코드는 긴데, axios 같은 라이브러리를 쓰면 코드가 줄어든다고 한다.


~~~ts
'use client'

import Link from 'next/link'

export default function ShowPage({result}) {

    return (
        <div>
            {result.map((a, i)=>(
                <div className="list-item" key={i}>
                    <Link href={ `/detail/${result[i]._id}`} >
                        <h4>{ result[i].title }</h4>
                    </Link>
                    <button onClick={(e)=>{
                        fetch('/api/delete', { 
                            method : 'DELETE',
                            body : a._id
                        }).then((r)=>r.json()).then(() => {
                            e.target.parentElement.style.opacity = 0
                        })
                    }}>🗑️</button>
                    <p> 1월 1일 </p>
                </div> 
            ))}
        </div>
    );
}
~~~

- button onclick={(e)} 이 e가 겁나 신기한 인자라고 한다.

~~~ts
import Link from 'next/link'

export default function ShowPage({result}) {

    return (
        <div>
            {result.map((a, i)=>(
                <div className="list-item" key={i}>
                    <Link href={ `/detail/${result[i]._id}`} >
                        <h4>{ result[i].title }</h4>
                    </Link>
                    <span onClick={(e)=>{
				        fetch('/api/test?name=gyopark&age=20')
                    }}>🗑️</span>    
                    <p> 1월 1일 </p>
                </div> 
            ))}
        </div>
    );
}
~~~

- query string의 장점, 간단하고, get 요청도 데이터 전송이 가능하다.
- 단점, 길고 복잡한 데이터를 집어넣으면 더럽다. 민감한 정보를 집어넣기 그렇다.

~~~ts
    <span onClick={(e)=>{
        fetch('/api/abc/kim')
    }}>🗑️</span>   
~~~

- url parameter 문법, /api/abc/[any].js에 { any:'kim' }이라는 쿼리 전달, any는 무조건 하나이다.

~~~ts

~~~


- 요약
(1) db document 삭제는 deleteone
(2) 서버와 ajax로 통신 가능
(3) 서버로 데이터 통신 시  queryString / URL Parameter 문법도 사용 가능