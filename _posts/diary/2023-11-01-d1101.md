---
layout: post
title: "2023년 10월 30일"
category: diary
---

~~~shell
Route (app)                                Size     First Load JS
┌ ○ /                                      146 B          80.5 kB
├ ○ /_not-found                            882 B          81.3 kB
├ λ /detail/[id]                           816 B          81.2 kB
├ λ /edit/[id]                             148 B          80.5 kB
├ ○ /join                                  148 B          80.5 kB
├ ○ /list                                  1 kB           88.3 kB
└ ○ /write                                 148 B          80.5 kB
+ First Load JS shared by all              80.4 kB
  ├ chunks/472-23f435a9c16afa13.js         27.5 kB
  ├ chunks/fd9d1056-e4950b334bc218cf.js    50.9 kB
  ├ chunks/main-app-0b180adc20fb58f8.js    230 B
  └ chunks/webpack-64e78a3cd6afbb95.js     1.73 kB

Route (pages)                              Size     First Load JS
┌ λ /api/abc/[any]                         0 B            79.9 kB
├ λ /api/delete                            0 B            79.9 kB
├ λ /api/post/account                      0 B            79.9 kB
├ λ /api/post/new                          0 B            79.9 kB
├ λ /api/post/update                       0 B            79.9 kB
├ λ /api/test                              0 B            79.9 kB
└ λ /api/time                              0 B            79.9 kB
+ First Load JS shared by all              79.9 kB
  ├ chunks/framework-8883d1e9be70c3da.js   45.2 kB
  ├ chunks/main-610627c68b9f221d.js        32.8 kB
  ├ chunks/pages/_app-1534f180665c857f.js  205 B
  └ chunks/webpack-64e78a3cd6afbb95.js     1.73 kB
~~~

- λ -> dynamic rendering / ○ -> static rendering
- next는 이 두 방식으로 페이지를 렌더링해서 사용자에게 보여줌

~~~ts
export const dynamic = 'force-dynamic'
~~~

- 페이지를 강제로 다이나믹 렌더링을 하도록 만든다.

- GET 요청 캐싱하기

~~~ts
	await fetch('/URL', {cache : 'force-cache'}) // GET 요청 결과 캐싱 가능
	// {cache : 'force-cache'} 안써도 캐싱 된다고 한다.
	// 캐싱 안할거면 {cache : 'no-store'}
	// {next : {revalidate : 60}}, 60초마다 캐싱된 데이터를 갱신한다.
~~~

~~~ts
export const revalidate = 60;
~~~

- 페이지 단위로 캐싱할 수 있는 예약 변수 revalidate. 시간마다 캐싱하기 때문에 자원을 아낄 수 있겠다.

(1) fetch

(2) revalidate 

를 통해 캐싱할 수 있다.

- 쿠키 저장소

(1) session 방식

(2) token 방식 (json web token)

- token 방식은 db를 조회할 필요가 없어서 db가 힘들지 않지만, 나쁜 사람이 입장권을 가져갈 수도 있다.


- OAUTH : 특정 사이트의 회원 정보를 가져와서 사용할 수 있다. 소셜 로그인
  => 트센 사이트를 만드는데, 42 로그인 정보를 가져다가 쓸거임, 42 로그인 정보로 token을 만들거나 할 수 있다.
  => 우리가 직접 아이디, 비번 관리를 할 필요가 없어 편하다

- next에는 OAUTH 기능을 지원한다. nextauth, 그런데 아이디/비밀번호 로그인 사용시 반드시 token 방법을 사용해야 한다.

