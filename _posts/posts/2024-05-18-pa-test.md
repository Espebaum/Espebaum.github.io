---
layout: post
title: "c++ 테스트 정리"
category: posts
---

* table of contents
{:toc}

# * c++ 테스트 정리

<center><img src="/assets/img/cover.png" width="50%" height="50%"></center><br>

- 이 포스트는 `Do it C++ 완전 정복`을 베이스로 작성되었습니다. 

- Do it C++의 깃허브는 이쪽입니다.
[Do It! C++ 완전 정복](https://github.com/mystous/DoItCPP){:target="_blank"}

* 단!돈! 32000원에 c++ 완전정복쌉가능 ~~(바이럴맞음)~~

### Chapter 3) 포인터와 메모리

#### 3-1 포인터와 메모리

##### Q1) 포인터 변수에 대해 정의하시오.
```
포인터 변수는 메모리 주소를 저장하는 변수이다.
```

##### Q2) 배열에 대해 정의하시오.
```
배열은 여러 변수의 묶음으로, 같은 자료형의 변수들이 연속적으로 메모리에 저장된 형태이다.
```

##### Q3) new, delete를 이용해 정수 50개를 수용할 수 있는 배열을 생성한 후 해제하는 코드를 작성하시오.
```c++
int* arr = new int[50];
delete[] arr;
```

#### 3-2 함수와 구조체

##### Q1) 함수에 대해 정의하시오.
```
함수란 특정한 역할을 수행하는 코드의 집합이다.
```

##### Q2) 구조체에 대해 정의하시오.
```
구조체란 하나 이상의 자료형을 묶어 만든 새로운 형태의 사용자 지정 자료형이다.
```

##### Q3) int 형식 포인터 변수를 매개변수로 가지는 함수 정의를 코드로 작성하시오.
```c++
void    func(int* pointer);
```

#### 3-3 정적 변수와 상수 변수

##### Q1) 정적 변수의 수명 주기가 지역 변수와 다른 이유를 설명하시오.

A) 정적 변수와 지역 변수의 수명 주기가 다른 이유는, **두 변수가 저장되는 메모리의 위치가 다르기 때문이다.** 메모리 구조는 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 구성되는데 지역 변수는 스택 영역에 저장된다. **스택 영역**의 변수는 함수가 호출될 때 메모리 할당되며 종료될 때 메모리에서 해제된다. 하지만 static으로 선언된 정적 변수는 데이터 영역에 저장된다. **데이터 영역**은 프로그램이 시작할 때 할당되며 종료할 때 해제된다.


##### Q2) `const int *ptr`과 `int *const ptr`의 차이점을 설명한 후, 아래 코드에서 컴파일 오류가 나는 지점을 체크하고, 그 이유를 설명하시오.

```c++
#include <iostream>

// 1번 main 문
int main()
{
    int a = 0;
    const int *ptr = &a;
    
    a = 1;
    *ptr = 2;
    return 0;
}

// 2번 main 문
int main()
{
    int a = 0;
    int b = 1;
    int *const ptr = &a;
    
    a = 1;
    ptr = &b;
    return 0;
}
```

1번 main 문의 const int *ptr은 ptr 포인터 변수가 가리키는 *ptr 값이 상수화된 것으로 변수 a 자체가 상수화된 것은 아니다. *ptr이 상수화되었으므로 *ptr = 2에서 컴파일 오류가 발생한다. 2번 main 문의 int *const ptr은 ptr 포인터 변수 자체를 const로 지정한 것으로, 다른 변수인 b의 주소로 변경할 수 없기 때문에 ptr = &b에서 컴파일 오류가 발생한다. 마찬가지로 a가 상수화된 것은 아니기 때문에 이 부분은 컴파일에 문제가 없다.

```
-> 결국 기억할 것은 const가 붙은 오른쪽 값이 상수화된다는 것이다.
const int *ptr => int *ptr이 상수화됨 -> (*ptr = 2) 처럼 변경 불가.
int *const ptr => ptr이 상수화됨 -> (ptr = &b) 처럼 변경 불가.
```

#### 3-3 레퍼런스 변수

##### Q1) 레퍼런스 변수의 정의를 서술하시오.
```
레퍼런스 변수는 변수의 또다른 이름으로 별칭 변수이다.
```

##### Q2) 레퍼런스 변수를 사용할 때 지켜야 할 점 3가지를 서술하시오

A) 첫 번째, 레퍼런스 변수는 선언할 때 반드시 참조할 원본 변수를 지정해야 한다. 두 번째, 참조할 대상이 지정된 레퍼런스 변수는 다른 변수를 참조하도록 변경해서는 안된다. 세 번째, 레퍼런스 변수로 상수를 참조해서는 안된다.

##### Q3) 레퍼런스와 포인터의 차이를 서술하시오.

A) 레퍼런스로 할 수 있는 기능은 포인터로도 할 수 있다. 포인터는 강력하지만 능숙하게 다루기 어렵다. 포인터를 다루다가 문제가 발생할 수도 있다. 레퍼런스는 포인터를 안전하게 사용할 수 있도록 만든 도구이다. 포인터처럼 원본 값에 접근할 수 있지만 원본 자체나 공간의 크기, 메모리 주소 등은 변경할 수 없다.

#### Chapter 4로 넘어가기 전에...

##### Q1) 동적으로 할당한 메모리를 반드시 해제해야 하는 이유는 무엇인지, 또 일반 변수를 메모리 해제하지 않아도 되는 이유에 대해 서술하시오.

동적 메모리 할당은 런타임에 필요에 따라 메모리를 할당한다. 하지만 일반 변수는 프로그램 시작 시 컴파일 타임에 컴파일러에 의해 메모리가 할당된다. 사용이 끝난 동적 메모리가 프로그램 종료 후에도 해제되지 않으면 메모리 누수가 발생한다. 메모리가 누수되어 사용량이 증가하면 시스템 성능 저하 및 충돌을 야기한다. 동적 메모리 할당 및 해제는 프로그래머에게 메모리 사용에 대한 직접적인 제어 권한을 제공한다. 이를 통해 프로그래머는 필요에 따라 메모리를 효율적으로 할당하고 해제하여 메모리 사용량을 최소화하고 프로그램 성능을 향상시킬 수 있다.

일반 변수는 프로그램 종료 시 컴파일러에 의해 자동으로 메모리가 해제되어 프로그래머가 직접 해제할 필요가 없다. 또한 일반 변수는 함수 범위 내에서만 유효하며 함수 종료 시 자동으로 메모리가 해제된다. 따라서 메모리 누수가 발생할 가능성이 낮다. 반면 동적 메모리는 프로그램 종료 전까지 유지될 수 있으며, 명확하게 해제하지 않으면 메모리 누수가 발생할 수 있다. 

##### Q2) 값에 의한 호출, 참조에 의한 호출, 주소에 의한 호출의 차이를 서술하시오.

**값에 의한 호출**은 함수 호출 시 인자의 값을 복사하여 함수 내에서 사용한다. **참조에 의한 호출**은 함수 호출 시 인자의 주소를 복사하여 함수 내에서 사용한다. **주소에 의한 호출**은 값에 의한 호출과 비슷하지만 인자 값을 복사하는 대신 포인터를 사용하여 직접 값을 변경한다. 


### Chapter 4) 실행 흐름 제어

##### Q1) 표현식과 구문의 정의에 대해 서술하고, 둘의 관계를 설명하시오.

**표현식**은 하나 이상의 변수, 연산자, 리터럴을 조합해 값을 평가하고 결과를 반환하는 코드를 의미한다. **구문**은 하나 이상의 연산을 수행하거나 동작을 실행하는 명령문의 집합으로 값을 할당하거나 프로그램의 실행 흐름을 제어한다. 구문은 컴파일러가 이해하고 실행할 수 있는 최소의 독립된 코드 조각이다. 코드 한 줄부터 여러 줄까지 구문으로 볼 수도 있다. 따라서 구문은 한 개 이상의 표현식과 키워드를 포함할 수 있다. **따라서 구문이 표현식을 포함하는 관계로 볼 수 있다.**

##### Q2) switch 분기를 활용하기 좋은 시점을 서술하시오.

조건부 분기가 많을 때, 분기 코드의 가독성을 높이기 위해 사용할 수 있다.

##### Q3) break 키워드의 기능을 서술하시오.

분기나 반복문에서 탈출하는 기능을 수행한다.

##### Q4) while문과 do-while문의 차이를 서술하시오.

두 반복문은 조건식을 평가하는 시점에 차이가 있다. while문은 반복을 실행하기 전에 조건을 평가하고, do-while문은 먼저 반복을 실행한 후 조건을 평가한다. 

##### Q5) `int result = a + b`에는 표현식과 구문이 모두 포함되어 있다. 어느 부분이 표현식이고 구문인지 표시하시오.

```c++
표현식 : a + b
구문 : int result = a + b;

int result = a + b; 는 표현식 a + b의 결과를 result 변수에 저장하는 구문이다.
```

### Chapter 5) 예외 처리 하기

#### Q1) 예외 처리란 무엇인지 서술하시오.

A) 예외 처리는 프로그램 실행 흐름상 발생하는 오류에 대응하는 것이다.

#### Q2) assertion을 이용한 예외 처리에 대해 서술하시오.

assertion은 코드를 검증하여 예상치 못한 상황에서 프로그램 동작을 중단시키는 도구로, 코드의 안전성과 신뢰성을 높여준다. c++에서는 assert 매크로를 통해 예외를 간단하게 처리할 수 있다. assert를 이용해 프로그램 특정 지점에서 true일 것으로 예상되는 조건을 지정한다. 만약 지정한 조건이 true가 아니면 프로그램 실행이 중단되며, 어떤 오류가 발생했는지 출력된다. 

#### Q3) noexcept를 이용한 예외 처리 생략에 대해 서술하시오.

함수가 예외를 던지지 않음을 나타낼 때 noexcept 키워드를 사용할 수 있다. 함수가 예외를 던지지 않음을 명시하면 컴파일러가 코드를 최적화하고 빠르게 실행하는데 도움이 된다. 그러나 함수에 noexcpet 키워드가 붙었다고 해서 예외를 던지지 못하는 것은 아니다. noexcept가 명시된 함수에서 예외가 발생하면 컴파일 경고 없이 런타임에 terminate()를 호출하며 프로그램이 종료된다.

#### Q4) set_terminate를 이용한 예외 처리 실패 대응에 대해 서술하시오.

런타임에 오류가 발생하면 내부적으로 terminate() 함수가 호출되며 프로그램이 종료되는데, 이때 종료 처리 함수를 설정하는 set_terminate로 프로그램이 강제 종료되기 전에 특정 동작을 수행하도록 구성할 수 있다. `set_terminate(my_function)`과 같이 사용할 수 있다.

## 2. 객체지향 프로그래밍

### Chapter 6) 객체지향과 클래스

#### 6-1 객체 지향 이전의 프로그래밍 패러다임

##### Q1) 절차적 프로그래밍과 그 효과를 기술하시오.

절차적 프로그래밍은 소스 코드를 여러 부분으로 나눠 활용하는 패러다임으로, 프로시저를 이용해 구조화하는 방식을 말한다. 프로시저는 일련의 코드 묶음으로, 보통 함수를 의미한다. 대표적으로 C언어, 포트란이 있다. 절차적 프로그래밍에선 코드의 논리 구조를 **모듈화**할 수 있다. 모듈화하면 같은 기능을 수행하는 코드를 다시 작성하지 않아도 재사용할 수 있으며 누군가가 만든 라이브러리 등을 이용하면 프로그램을 더 쉽게 개발할 수 있다. 또한 구조화된 코드는 다른 사람이 쉽게 읽을 수 있는 장점이 있다.

##### Q2) 절차적 프로그래밍의 한계를 기술하시오.

절차적 프로그래밍은 프로그래밍 대상을 논리 구조인 프로시저로 표현하는 것이 매우 복잡하다. 프로시저가 가진 논리적 다층 구조를 프로그래밍 내부에서 표현하는 데 한계가 있다. 불필요한 프로시저를 호출하거나 전역 변수를 수정할 수 있다. 이때 프로그램 동작에 치명적인 영향을 줄 수 있다.

#### 6-2 객체지향 프로그래밍

##### Q1) 객체지향 프로그래밍을 정의하시오.

객체지향 프로그래밍이란 데이터와 함수를 포함하는 객체를 활용하는 프로그래밍 패러다임이다. 다양한 객체 간의 관계로 원하는 목적의 소프트웨어 프로그램을 완성한다.

##### Q2) has-a 관계와 is-a 관계에 대해 서술하시오.

객체 간의 상속이나 포함 관계에서 상위, 하위 객체가 교환되는 관계를 is-a 관계라 하고, 교환이 불가능한 관계를 has-a 관계라고 한다.

##### Q3) 객체지향 프로그래밍의 특징에 대해 기술하시오.

객체지향 프로그래밍의 특징에는 추상화, 캡슐화, 상속성, 다형성이 있다. **추상화**는 현실 세계의 사물을 모델링하여 객체로 만들 때, 어떤 부류에서 불필요한 요소는 배제하고 공통된 특징만을 추출하는 것이다. **캡슐화**는 복잡한 내부 기능을 묶어 외부에 불필요한 정보를 감추는 것이다. **상속**은 파생 객체가 부모 객체의 특성을 이어받는 것이다. **다형성**은 상속받은 객체가 자신만의 기능을 반영하여 다른 방식으로 동작하는 것이다.

#### 6-3 클래스와 인스턴스

##### Q1) 클래스의 정의에 대해 서술하시오.

A) 클래스는 객체가 포함하는 데이터와 함수를 정의하는 문법적 요소이다.

##### Q2) 객체와 클래스의 차이와, 객체와 클래스의 관계에 대해서 서술하시오.

A) 객체와 클래스의 관계는 자료형과 변수의 관계와 비교할 수 있다. 객체는 클래스를 사용할 수 있도록 만든 변수이다. 객체와 클래스는 다대일 관계이다. 

#### Chapter 7로 넘어가기 전에...

##### Q1) 비구조적 프로그래밍과 절차적 프로그래밍의 장단점을 비교하여 각 패러다임을 대표하는 언어가 무엇인지 기술하시오.

A) **비구조적 프로그래밍은 코드를 구조화하지 않고 작성한다.** 순차적인 흐름 이해만으로 소스 코드를 이해할 수 있다. 하지만 복잡한 구조를 표현하기 어렵고, 스파게티 코드가 만들어질 가능성이 있다. **절차적 프로그래밍**은 프로시저를 이용해 구조화하는 방식이다. 프로시저로 모듈화를 구현하여 복잡한 구조를 표현할 수 있고 개념화가 쉽다. 다만 접근 제어가 어렵고 전역 범위에 대한 접근이 불가피하다. 비구조적 프로그래밍 언어로는 Assembly와 초기 fortran이 있고, 절차적 프로그래밍 언어로는 C, COBOL, fortran 등이 있다.

### Chapter 7 객체지향 프로그래밍 특징

#### 7-1 추상화와 캡슐화

##### Q1) 객체지향 프로그래밍에서 캡슐화를 통해 얻을 수 있는 장점은 무엇인지 서술하시오.

A) 속성(멤버 변수)과 행위(멤버 함수)를 하나의 클래스로 묶어서 관리함으로써 복잡도를 낮추고 수정하기가 용이하다. 또한 클래스 외부에서 내부의 정보에 접근할 수 없도록 은닉(hiding)하기 때문에 보안성을 높이고 실수를 방지할 수 있다.

##### Q2) C++에서 추상화는 어떤 의미인지 서술하시오.

A) C++의 추상화는 현실의 사물들을 모델링하여 객체를 만들 때, 공통된 부분은 추려내고 불필요한 부분은 제거하여 코드를 간결하고 이해하기 쉽게 만드는 작업이다.

#### 7-2 상속성과 다형성

##### Q1) 객체지향 프로그래밍에서 상속성이 무엇이고 왜 중요한지 서술하시오.

A) 상속성은 기본 클래스로부터 파생 클래스가 생성될 때, 그 속성과 기능을 이어받아 확장하는 것을 의미한다. 상속을 통해 논리적 포함 관계와 공통의 특질을 명확하게 모델링할 수 있다. 상속은 클래스를 설계하고 재사용하는 핵심적인 개념이기 때문에 중요하다.

##### Q2) 다형성 구현을 위해 C++에서 사용하는 문법이나 기법은 무엇인지 서술하시오.

A) 다형성은 하나의 클래스가 다양한 형태의 속성과 기능을 가질 수 있다는 것을 의미한다. 파생 클래스는 기본 클래스의 역할을 대신할 수 있으면서 고유한 특징을 가지고 동작한다. 다형성을 구현하기 위해 C++에서는 가상 함수를 이용한 함수의 오버라이딩을 사용한다.

##### Q3) 가상 함수를 사용하지 않고 오버라이딩하면 어떤 문제가 발생하는지 서술하시오.

A) 기본 클래스 포인터로 파생 클래스에 접근하면 자식 클래스의 오버라이딩된 함수가 아닌 부모 클래스의 함수가 호출된다.

##### I4) 오버라이딩과 오버로딩 추가 정보

부모의 멤버 함수와 같은 시그니처로 자식 클래스에서 재정의하는 것을 **오버라이딩**이라고 한다. 그리고 함수 이름만 같고 매개변수 구성이 다른 함수를 만드는 것을 **오버로딩**이라고 한다. 오버라이딩 함수는 네임스페이스로 원본함수를 선택해서 호출하지만, 오버로딩 함수는 호출 인자에 따라서 알맞은 함수가 호출된다.

#### 7-3 생성자와 소멸자

##### Q1) 소멸자를 가상 함수로 정의해야 하는 때는 어떤 경우인지 서술하시오.

A) 다형성을 구현하기 위해 기본 클래스 포인터로 자식 객체를 처리하였을 때, 기본 클래스 소멸자를 가상 함수로 정의해야 한다.

##### Q2) 사용자가 복사 생성자를 직접 정의하지 않으면 객체를 대입할 때 어떤 복사가 이루어지는지 서술하시오.

A) 사용자가 복사 생성자를 직접 정의하지 않으면 객체를 대입할 때 **얕은 복사**가 이루어진다.

##### Q3) 정적 멤버 변수의 초기화 위치는 어디인지, 레퍼런스 변수는 무엇을 사용해서 초기화해야 하는지 서술하시오.

A) 정적 멤버 변수는 전역 범위에서 초기화되어야 하고, 레퍼런스 변수는 반드시 초기화자 리스트를 사용해야 한다. 생성자 본문에서는 이미 객체가 생성된 상태이고, 이는 객체가 생성되기 전에 모든 멤버가 유효한 상태로 존재해야 한다는 C++의 규칙을 위반하기 떄문이다.

#### 7-4 자신을 가리키는 this 포인터

##### Q1) 객체 자신을 레퍼런스 또는 포인터로 반환하여 연속된 호출 형태를 만드는 방법을 무엇이라고 하는가?

A) 멤버 함수 체이닝

##### I2) 멤버 함수는 클래스 메모리 영역이 아닌 코드 메모리에 위치해서 같은 클래스로 갱성한 객체가 공유하기 때문에 this 포인터를 활용하여 멤버 변수를 구분해야 한다.