---
layout: post
title: "c++ 테스트 정리"
category: posts
---

* table of contents
{:toc}

# * c++ 테스트 정리

<center><img src="/assets/img/cover.png" width="50%" height="50%"></center><br>

- 이 포스트는 `Do it C++ 완전 정복`을 베이스로 작성되었습니다. 

- Do it C++의 깃허브는 이쪽입니다.
[Do It! C++ 완전 정복](https://github.com/mystous/DoItCPP){:target="_blank"}

* 단돈 32000원에 c++ 완전정복쌉가능 ~~(바이럴맞음)~~

### Chapter 3) 포인터와 메모리

#### 3-1 포인터와 메모리

##### Q1) 포인터 변수에 대해 정의하시오.
```
포인터 변수는 메모리 주소를 저장하는 변수이다.
```

##### Q2) 배열에 대해 정의하시오.
```
배열은 여러 변수의 묶음으로, 같은 자료형의 변수들이 연속적으로 메모리에 저장된 형태이다.
```

##### Q3) new, delete를 이용해 정수 50개를 수용할 수 있는 배열을 생성한 후 해제하는 코드를 작성하시오.
```c++
int* arr = new int[50];
delete[] arr;
```

#### 3-2 함수와 구조체

##### Q1) 함수에 대해 정의하시오.
```
함수란 특정한 역할을 수행하는 코드의 집합이다.
```

##### Q2) 구조체에 대해 정의하시오.
```
구조체란 하나 이상의 자료형을 묶어 만든 새로운 형태의 사용자 지정 자료형이다.
```

##### Q3) int 형식 포인터 변수를 매개변수로 가지는 함수 정의를 코드로 작성하시오.
```c++
void    func(int* pointer);
```

#### 3-3 정적 변수와 상수 변수

##### Q1) 정적 변수의 수명 주기가 지역 변수와 다른 이유를 설명하시오.

A) 정적 변수와 지역 변수의 수명 주기가 다른 이유는, **두 변수가 저장되는 메모리의 위치가 다르기 때문이다.** 메모리 구조는 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 구성되는데 지역 변수는 스택 영역에 저장된다. **스택 영역**의 변수는 함수가 호출될 때 메모리 할당되며 종료될 때 메모리에서 해제된다. 하지만 static으로 선언된 정적 변수는 데이터 영역에 저장된다. **데이터 영역**은 프로그램이 시작할 때 할당되며 종료할 때 해제된다.


##### Q2) `const int *ptr`과 `int *const ptr`의 차이점을 설명한 후, 아래 코드에서 컴파일 오류가 나는 지점을 체크하고, 그 이유를 설명하시오.

```c++
#include <iostream>

// 1번 main 문
int main()
{
    int a = 0;
    const int *ptr = &a;
    
    a = 1;
    *ptr = 2;
    return 0;
}

// 2번 main 문
int main()
{
    int a = 0;
    int b = 1;
    int *const ptr = &a;
    
    a = 1;
    ptr = &b;
    return 0;
}
```

1번 main 문의 const int *ptr은 ptr 포인터 변수가 가리키는 *ptr 값이 상수화된 것으로 변수 a 자체가 상수화된 것은 아니다. *ptr이 상수화되었으므로 *ptr = 2에서 컴파일 오류가 발생한다. 2번 main 문의 int *const ptr은 ptr 포인터 변수 자체를 const로 지정한 것으로, 다른 변수인 b의 주소로 변경할 수 없기 때문에 ptr = &b에서 컴파일 오류가 발생한다. 마찬가지로 a가 상수화된 것은 아니기 때문에 이 부분은 컴파일에 문제가 없다.

```
-> 결국 기억할 것은 const가 붙은 오른쪽 값이 상수화된다는 것이다.
const int *ptr => int *ptr이 상수화됨 -> (*ptr = 2) 처럼 변경 불가.
int *const ptr => ptr이 상수화됨 -> (ptr = &b) 처럼 변경 불가.
```

#### 3-3 레퍼런스 변수

##### Q1) 레퍼런스 변수의 정의를 서술하시오.
```
레퍼런스 변수는 변수의 또다른 이름으로 별칭 변수이다.
```

##### Q2) 레퍼런스 변수를 사용할 때 지켜야 할 점 3가지를 서술하시오

A) 첫 번째, 레퍼런스 변수는 선언할 때 반드시 참조할 원본 변수를 지정해야 한다. 두 번째, 참조할 대상이 지정된 레퍼런스 변수는 다른 변수를 참조하도록 변경해서는 안된다. 세 번째, 레퍼런스 변수로 상수를 참조해서는 안된다.

##### Q3) 레퍼런스와 포인터의 차이를 서술하시오.

A) 레퍼런스로 할 수 있는 기능은 포인터로도 할 수 있다. 포인터는 강력하지만 능숙하게 다루기 어렵다. 포인터를 다루다가 문제가 발생할 수도 있다. 레퍼런스는 포인터를 안전하게 사용할 수 있도록 만든 도구이다. 포인터처럼 원본 값에 접근할 수 있지만 원본 자체나 공간의 크기, 메모리 주소 등은 변경할 수 없다.

#### Chapter 4로 넘어가기 전에...

##### Q1) 동적으로 할당한 메모리를 반드시 해제해야 하는 이유는 무엇인지, 또 일반 변수를 메모리 해제하지 않아도 되는 이유에 대해 서술하시오.

동적 메모리 할당은 런타임에 필요에 따라 메모리를 할당한다. 하지만 일반 변수는 프로그램 시작 시 컴파일 타임에 컴파일러에 의해 메모리가 할당된다. 사용이 끝난 동적 메모리가 프로그램 종료 후에도 해제되지 않으면 메모리 누수가 발생한다. 메모리가 누수되어 사용량이 증가하면 시스템 성능 저하 및 충돌을 야기한다. 동적 메모리 할당 및 해제는 프로그래머에게 메모리 사용에 대한 직접적인 제어 권한을 제공한다. 이를 통해 프로그래머는 필요에 따라 메모리를 효율적으로 할당하고 해제하여 메모리 사용량을 최소화하고 프로그램 성능을 향상시킬 수 있다.

일반 변수는 프로그램 종료 시 컴파일러에 의해 자동으로 메모리가 해제되어 프로그래머가 직접 해제할 필요가 없다. 또한 일반 변수는 함수 범위 내에서만 유효하며 함수 종료 시 자동으로 메모리가 해제된다. 따라서 메모리 누수가 발생할 가능성이 낮다. 반면 동적 메모리는 프로그램 종료 전까지 유지될 수 있으며, 명확하게 해제하지 않으면 메모리 누수가 발생할 수 있다. 

##### Q2) 값에 의한 호출, 참조에 의한 호출, 주소에 의한 호출의 차이를 서술하시오.

**값에 의한 호출**은 함수 호출 시 인자의 값을 복사하여 함수 내에서 사용한다. **참조에 의한 호출**은 함수 호출 시 인자의 주소를 복사하여 함수 내에서 사용한다. **주소에 의한 호출**은 값에 의한 호출과 비슷하지만 인자 값을 복사하는 대신 포인터를 사용하여 직접 값을 변경한다. 


### Chapter 4) 실행 흐름 제어

##### Q1) 표현식과 구문의 정의에 대해 서술하고, 둘의 관계를 설명하시오.

**표현식**은 하나 이상의 변수, 연산자, 리터럴을 조합해 값을 평가하고 결과를 반환하는 코드를 의미한다. **구문**은 하나 이상의 연산을 수행하거나 동작을 실행하는 명령문의 집합으로 값을 할당하거나 프로그램의 실행 흐름을 제어한다. 구문은 컴파일러가 이해하고 실행할 수 있는 최소의 독립된 코드 조각이다. 코드 한 줄부터 여러 줄까지 구문으로 볼 수도 있다. 따라서 구문은 한 개 이상의 표현식과 키워드를 포함할 수 있다. **따라서 구문이 표현식을 포함하는 관계로 볼 수 있다.**

##### Q2) switch 분기를 활용하기 좋은 시점을 서술하시오.

조건부 분기가 많을 때, 분기 코드의 가독성을 높이기 위해 사용할 수 있다.

##### Q3) break 키워드의 기능을 서술하시오.

분기나 반복문에서 탈출하는 기능을 수행한다.

##### Q4) while문과 do-while문의 차이를 서술하시오.

두 반복문은 조건식을 평가하는 시점에 차이가 있다. while문은 반복을 실행하기 전에 조건을 평가하고, do-while문은 먼저 반복을 실행한 후 조건을 평가한다. 

##### Q5) `int result = a + b`에는 표현식과 구문이 모두 포함되어 있다. 어느 부분이 표현식이고 구문인지 표시하시오.

```c++
표현식 : a + b
구문 : int result = a + b;

int result = a + b; 는 표현식 a + b의 결과를 result 변수에 저장하는 구문이다.
```

### Chapter 5) 예외 처리 하기

#### Q1) 예외 처리란 무엇인지 서술하시오.

A) 예외 처리는 프로그램 실행 흐름상 발생하는 오류에 대응하는 것이다.

#### Q2) assertion을 이용한 예외 처리에 대해 서술하시오.

assertion은 코드를 검증하여 예상치 못한 상황에서 프로그램 동작을 중단시키는 도구로, 코드의 안전성과 신뢰성을 높여준다. c++에서는 assert 매크로를 통해 예외를 간단하게 처리할 수 있다. assert를 이용해 프로그램 특정 지점에서 true일 것으로 예상되는 조건을 지정한다. 만약 지정한 조건이 true가 아니면 프로그램 실행이 중단되며, 어떤 오류가 발생했는지 출력된다. 

#### Q3) noexcept를 이용한 예외 처리 생략에 대해 서술하시오.

함수가 예외를 던지지 않음을 나타낼 때 noexcept 키워드를 사용할 수 있다. 함수가 예외를 던지지 않음을 명시하면 컴파일러가 코드를 최적화하고 빠르게 실행하는데 도움이 된다. 그러나 함수에 noexcpet 키워드가 붙었다고 해서 예외를 던지지 못하는 것은 아니다. noexcept가 명시된 함수에서 예외가 발생하면 컴파일 경고 없이 런타임에 terminate()를 호출하며 프로그램이 종료된다.

#### Q4) set_terminate를 이용한 예외 처리 실패 대응에 대해 서술하시오.

런타임에 오류가 발생하면 내부적으로 terminate() 함수가 호출되며 프로그램이 종료되는데, 이때 종료 처리 함수를 설정하는 set_terminate로 프로그램이 강제 종료되기 전에 특정 동작을 수행하도록 구성할 수 있다. `set_terminate(my_function)`과 같이 사용할 수 있다.

## 2. 객체지향 프로그래밍

### Chapter 6) 객체지향과 클래스

#### 6-1 객체 지향 이전의 프로그래밍 패러다임

##### Q1) 절차적 프로그래밍과 그 효과를 기술하시오.

절차적 프로그래밍은 소스 코드를 여러 부분으로 나눠 활용하는 패러다임으로, 프로시저를 이용해 구조화하는 방식을 말한다. 프로시저는 일련의 코드 묶음으로, 보통 함수를 의미한다. 대표적으로 C언어, 포트란이 있다. 절차적 프로그래밍에선 코드의 논리 구조를 **모듈화**할 수 있다. 모듈화하면 같은 기능을 수행하는 코드를 다시 작성하지 않아도 재사용할 수 있으며 누군가가 만든 라이브러리 등을 이용하면 프로그램을 더 쉽게 개발할 수 있다. 또한 구조화된 코드는 다른 사람이 쉽게 읽을 수 있는 장점이 있다.

##### Q2) 절차적 프로그래밍의 한계를 기술하시오.

절차적 프로그래밍은 프로그래밍 대상을 논리 구조인 프로시저로 표현하는 것이 매우 복잡하다. 프로시저가 가진 논리적 다층 구조를 프로그래밍 내부에서 표현하는 데 한계가 있다. 불필요한 프로시저를 호출하거나 전역 변수를 수정할 수 있다. 이때 프로그램 동작에 치명적인 영향을 줄 수 있다.

